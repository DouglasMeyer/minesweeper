{"version":3,"sources":["webpack:///peer_web.js","webpack:///webpack/bootstrap 81b94873f4642fb1a79b","webpack:///./~/peerjs/lib/util.js","webpack:///./~/peerjs/lib/adapter.js","webpack:///./~/peerjs/~/eventemitter3/index.js","webpack:///./~/js-binarypack/lib/binarypack.js","webpack:///./~/js-binarypack/lib/bufferbuilder.js","webpack:///./~/peerjs/lib/negotiator.js","webpack:///./index.js","webpack:///./index.js?ee6e","webpack:///./~/peerjs/lib/dataconnection.js","webpack:///./~/peerjs/lib/mediaconnection.js","webpack:///./~/peerjs/lib/peer.js","webpack:///./~/peerjs/lib/socket.js","webpack:///./~/reliable/lib/reliable.js","webpack:///./~/reliable/lib/util.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","defaultConfig","iceServers","url","dataCount","BinaryPack","RTCPeerConnection","util","noop","CLOUD_HOST","CLOUD_PORT","chunkedBrowsers","Chrome","chunkedMTU","logLevel","setLogLevel","level","debugLevel","parseInt","isNaN","log","warn","error","_printWith","_print","setLogFunction","fn","constructor","Function","prefix","copy","Array","prototype","slice","arguments","unshift","apply","err","i","l","length","Error","name","message","console","browser","window","mozRTCPeerConnection","webkitRTCPeerConnection","supports","pc","dc","data","audioVideo","binaryBlob","sctp","onnegotiationneeded","optional","RtpDataChannels","e","createDataChannel","binaryType","reliablePC","reliableDC","reliable","close","addStream","negotiationPC","setTimeout","binary","validateId","exec","validateKey","key","debug","inherits","ctor","superCtor","super_","Object","create","value","enumerable","writable","configurable","extend","dest","source","hasOwnProperty","pack","unpack","setZeroTimeout","global","setZeroTimeoutPostMessage","timeouts","push","postMessage","messageName","handleMessage","event","stopPropagation","shift","addEventListener","attachEvent","chunk","bl","chunks","size","start","index","total","Math","ceil","end","min","b","__peerData","n","blobToArrayBuffer","blob","cb","fr","FileReader","onload","evt","target","result","readAsArrayBuffer","blobToBinaryString","readAsBinaryString","binaryStringToArrayBuffer","byteArray","Uint8Array","charCodeAt","buffer","randomToken","random","toString","substr","isSecure","location","protocol","RTCSessionDescription","mozRTCSessionDescription","RTCIceCandidate","mozRTCIceCandidate","EE","context","once","this","EventEmitter","_events","undefined","listeners","ee","emit","a1","a2","a3","a4","a5","args","len","removeListener","j","on","listener","events","removeAllListeners","off","addListener","setMaxListeners","EventEmitter2","EventEmitter3","Unpacker","dataBuffer","dataView","byteLength","Packer","bufferBuilder","BufferBuilder","_utf8Replace","code","utf8Length","str","Blob","replace","binaryFeatures","unpacker","packer","getBuffer","type","unpack_uint8","positive_fixnum","negative_fixnum","unpack_raw","unpack_string","unpack_array","unpack_map","unpack_float","unpack_double","unpack_uint16","unpack_uint32","unpack_uint64","unpack_int8","unpack_int16","unpack_int32","unpack_int64","byte","bytes","read","uint16","uint32","uint64","uint8","pow","buf","String","fromCharCode","objects","map","sign","exp","fraction","h32","l32","hfrac","frac","subarray","pack_string","floor","pack_integer","pack_double","append","pack_array","File","pack_bin","ArrayBuffer","useArrayBufferView","pack_object","Date","toBinaryPack","flush","pack_uint8","pack_uint16","pack_uint32","ary","num","pack_int8","pack_int16","pack_int32","pack_int64","pack_uint64","LN2","frac0","frac1","b32","obj","keys","prop","high","low","_pieces","_parts","useBlobBuilder","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","builder","ii","getBlob","Negotiator","pcs","media","queue","_idPrefix","startConnection","connection","options","_getPeerConnection","_stream","peerConnection","originator","config","label","initialize","_makeOffer","handleSDP","sdp","peer","signalingState","_startPeerConnection","DtlsSrtpKeyAgreement","provider","_setupListeners","pc_id","peerId","connectionId","onicecandidate","candidate","socket","send","payload","dst","oniceconnectionstatechange","iceConnectionState","onicechange","ondatachannel","channel","getConnection","onaddstream","stream","cleanup","readyState","createOffer","offer","Reliable","higherBandwidthSDP","setLocalDescription","serialization","metadata","emitError","constraints","_makeAnswer","createAnswer","answer","setRemoteDescription","handleCandidate","ice","sdpMLineIndex","addIceCandidate","_interopRequireDefault","__esModule","default","PeerWeb","existingPeer","trigger","action","_len","_key","callbacks","forEach","tryPotentialPeers","disconnected","potentialPeers","setupConnection","connect","splice","connections","bind","indexOf","_this","_peerjs2","a","peer-unavailable","match","addPeer","_len2","_key2","reconnect","destroy","actions","defineProperty","_peerjs","Open","Connected","Data","Disconnected","Close","Unavailable","DataConnection","open","_buffer","_buffering","bufferSize","_chunkedData","_payload","_peerBrowser","_dc","dataChannel","_configureDataChannel","self","onopen","_reliable","onmessage","msg","_handleDataMessage","onclose","datatype","ab","JSON","parse","chunkInfo","count","chunked","_bufferedSend","stringify","needsChunking","_sendChunks","_trySend","_tryBuffer","blobs","MediaConnection","localStream","remoteStream","messages","_getMessages","Peer","host","port","path","token","hostname","secure","logFunction","_delayedAbort","destroyed","_lostMessages","_initializeServerConnection","_initialize","_retrieveId","Socket","_handleMessage","_abort","disconnect","http","XMLHttpRequest","queryString","getTime","onerror","pathError","onreadystatechange","status","responseText","src","_cleanupPeer","_addConnection","_storeMessage","_lastServerId","_cleanup","peers","jj","listAllPeers","helpfulError","_queue","httpProtocol","wsProtocol","_httpUrl","_wsUrl","_startXhrStream","_startWebSocket","_socket","WebSocket","_timeout","clearTimeout","_http","abort","_sendQueuedMessages","_index","_streamIndex","old","_handleStream","_setHTTPTimeout","split","bufferedMessage","_wsOpen","toLowerCase","setRequestHeader","_outgoing","_incoming","_received","_window","_mtu","_interval","_count","_setupDC","_handleSend","ack","_chunk","timer","_sendWindowedChunks","_setupInterval","setInterval","_multiple","_intervalSend","_processAcks","item","idata","odata","_ack","max","_calculateNextAck","_complete","ch","limit","sent","version","navigator","appVersion","parts"],"mappings":"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","file":"peer_web.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(8);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar defaultConfig = {'iceServers': [{ 'url': 'stun:stun.l.google.com:19302' }]};\n\tvar dataCount = 1;\n\t\n\tvar BinaryPack = __webpack_require__(4);\n\tvar RTCPeerConnection = __webpack_require__(2).RTCPeerConnection;\n\t\n\tvar util = {\n\t  noop: function() {},\n\t\n\t  CLOUD_HOST: '0.peerjs.com',\n\t  CLOUD_PORT: 9000,\n\t\n\t  // Browsers that need chunking:\n\t  chunkedBrowsers: {'Chrome': 1},\n\t  chunkedMTU: 16300, // The original 60000 bytes setting does not work when sending data from Firefox to Chrome, which is \"cut off\" after 16384 bytes and delivered individually.\n\t\n\t  // Logging logic\n\t  logLevel: 0,\n\t  setLogLevel: function(level) {\n\t    var debugLevel = parseInt(level, 10);\n\t    if (!isNaN(parseInt(level, 10))) {\n\t      util.logLevel = debugLevel;\n\t    } else {\n\t      // If they are using truthy/falsy values for debug\n\t      util.logLevel = level ? 3 : 0;\n\t    }\n\t    util.log = util.warn = util.error = util.noop;\n\t    if (util.logLevel > 0) {\n\t      util.error = util._printWith('ERROR');\n\t    }\n\t    if (util.logLevel > 1) {\n\t      util.warn = util._printWith('WARNING');\n\t    }\n\t    if (util.logLevel > 2) {\n\t      util.log = util._print;\n\t    }\n\t  },\n\t  setLogFunction: function(fn) {\n\t    if (fn.constructor !== Function) {\n\t      util.warn('The log function you passed in is not a function. Defaulting to regular logs.');\n\t    } else {\n\t      util._print = fn;\n\t    }\n\t  },\n\t\n\t  _printWith: function(prefix) {\n\t    return function() {\n\t      var copy = Array.prototype.slice.call(arguments);\n\t      copy.unshift(prefix);\n\t      util._print.apply(util, copy);\n\t    };\n\t  },\n\t  _print: function () {\n\t    var err = false;\n\t    var copy = Array.prototype.slice.call(arguments);\n\t    copy.unshift('PeerJS: ');\n\t    for (var i = 0, l = copy.length; i < l; i++){\n\t      if (copy[i] instanceof Error) {\n\t        copy[i] = '(' + copy[i].name + ') ' + copy[i].message;\n\t        err = true;\n\t      }\n\t    }\n\t    err ? console.error.apply(console, copy) : console.log.apply(console, copy);\n\t  },\n\t  //\n\t\n\t  // Returns browser-agnostic default config\n\t  defaultConfig: defaultConfig,\n\t  //\n\t\n\t  // Returns the current browser.\n\t  browser: (function() {\n\t    if (window.mozRTCPeerConnection) {\n\t      return 'Firefox';\n\t    } else if (window.webkitRTCPeerConnection) {\n\t      return 'Chrome';\n\t    } else if (window.RTCPeerConnection) {\n\t      return 'Supported';\n\t    } else {\n\t      return 'Unsupported';\n\t    }\n\t  })(),\n\t  //\n\t\n\t  // Lists which features are supported\n\t  supports: (function() {\n\t    if (typeof RTCPeerConnection === 'undefined') {\n\t      return {};\n\t    }\n\t\n\t    var data = true;\n\t    var audioVideo = true;\n\t\n\t    var binaryBlob = false;\n\t    var sctp = false;\n\t    var onnegotiationneeded = !!window.webkitRTCPeerConnection;\n\t\n\t    var pc, dc;\n\t    try {\n\t      pc = new RTCPeerConnection(defaultConfig, {optional: [{RtpDataChannels: true}]});\n\t    } catch (e) {\n\t      data = false;\n\t      audioVideo = false;\n\t    }\n\t\n\t    if (data) {\n\t      try {\n\t        dc = pc.createDataChannel('_PEERJSTEST');\n\t      } catch (e) {\n\t        data = false;\n\t      }\n\t    }\n\t\n\t    if (data) {\n\t      // Binary test\n\t      try {\n\t        dc.binaryType = 'blob';\n\t        binaryBlob = true;\n\t      } catch (e) {\n\t      }\n\t\n\t      // Reliable test.\n\t      // Unfortunately Chrome is a bit unreliable about whether or not they\n\t      // support reliable.\n\t      var reliablePC = new RTCPeerConnection(defaultConfig, {});\n\t      try {\n\t        var reliableDC = reliablePC.createDataChannel('_PEERJSRELIABLETEST', {});\n\t        sctp = reliableDC.reliable;\n\t      } catch (e) {\n\t      }\n\t      reliablePC.close();\n\t    }\n\t\n\t    // FIXME: not really the best check...\n\t    if (audioVideo) {\n\t      audioVideo = !!pc.addStream;\n\t    }\n\t\n\t    // FIXME: this is not great because in theory it doesn't work for\n\t    // av-only browsers (?).\n\t    if (!onnegotiationneeded && data) {\n\t      // sync default check.\n\t      var negotiationPC = new RTCPeerConnection(defaultConfig, {optional: [{RtpDataChannels: true}]});\n\t      negotiationPC.onnegotiationneeded = function() {\n\t        onnegotiationneeded = true;\n\t        // async check.\n\t        if (util && util.supports) {\n\t          util.supports.onnegotiationneeded = true;\n\t        }\n\t      };\n\t      negotiationPC.createDataChannel('_PEERJSNEGOTIATIONTEST');\n\t\n\t      setTimeout(function() {\n\t        negotiationPC.close();\n\t      }, 1000);\n\t    }\n\t\n\t    if (pc) {\n\t      pc.close();\n\t    }\n\t\n\t    return {\n\t      audioVideo: audioVideo,\n\t      data: data,\n\t      binaryBlob: binaryBlob,\n\t      binary: sctp, // deprecated; sctp implies binary support.\n\t      reliable: sctp, // deprecated; sctp implies reliable data.\n\t      sctp: sctp,\n\t      onnegotiationneeded: onnegotiationneeded\n\t    };\n\t  }()),\n\t  //\n\t\n\t  // Ensure alphanumeric ids\n\t  validateId: function(id) {\n\t    // Allow empty ids\n\t    return !id || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(id);\n\t  },\n\t\n\t  validateKey: function(key) {\n\t    // Allow empty keys\n\t    return !key || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(key);\n\t  },\n\t\n\t\n\t  debug: false,\n\t\n\t  inherits: function(ctor, superCtor) {\n\t    ctor.super_ = superCtor;\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  },\n\t  extend: function(dest, source) {\n\t    for(var key in source) {\n\t      if(source.hasOwnProperty(key)) {\n\t        dest[key] = source[key];\n\t      }\n\t    }\n\t    return dest;\n\t  },\n\t  pack: BinaryPack.pack,\n\t  unpack: BinaryPack.unpack,\n\t\n\t  log: function () {\n\t    if (util.debug) {\n\t      var err = false;\n\t      var copy = Array.prototype.slice.call(arguments);\n\t      copy.unshift('PeerJS: ');\n\t      for (var i = 0, l = copy.length; i < l; i++){\n\t        if (copy[i] instanceof Error) {\n\t          copy[i] = '(' + copy[i].name + ') ' + copy[i].message;\n\t          err = true;\n\t        }\n\t      }\n\t      err ? console.error.apply(console, copy) : console.log.apply(console, copy);\n\t    }\n\t  },\n\t\n\t  setZeroTimeout: (function(global) {\n\t    var timeouts = [];\n\t    var messageName = 'zero-timeout-message';\n\t\n\t    // Like setTimeout, but only takes a function argument.\t There's\n\t    // no time argument (always zero) and no arguments (you have to\n\t    // use a closure).\n\t    function setZeroTimeoutPostMessage(fn) {\n\t      timeouts.push(fn);\n\t      global.postMessage(messageName, '*');\n\t    }\n\t\n\t    function handleMessage(event) {\n\t      if (event.source == global && event.data == messageName) {\n\t        if (event.stopPropagation) {\n\t          event.stopPropagation();\n\t        }\n\t        if (timeouts.length) {\n\t          timeouts.shift()();\n\t        }\n\t      }\n\t    }\n\t    if (global.addEventListener) {\n\t      global.addEventListener('message', handleMessage, true);\n\t    } else if (global.attachEvent) {\n\t      global.attachEvent('onmessage', handleMessage);\n\t    }\n\t    return setZeroTimeoutPostMessage;\n\t  }(window)),\n\t\n\t  // Binary stuff\n\t\n\t  // chunks a blob.\n\t  chunk: function(bl) {\n\t    var chunks = [];\n\t    var size = bl.size;\n\t    var start = index = 0;\n\t    var total = Math.ceil(size / util.chunkedMTU);\n\t    while (start < size) {\n\t      var end = Math.min(size, start + util.chunkedMTU);\n\t      var b = bl.slice(start, end);\n\t\n\t      var chunk = {\n\t        __peerData: dataCount,\n\t        n: index,\n\t        data: b,\n\t        total: total\n\t      };\n\t\n\t      chunks.push(chunk);\n\t\n\t      start = end;\n\t      index += 1;\n\t    }\n\t    dataCount += 1;\n\t    return chunks;\n\t  },\n\t\n\t  blobToArrayBuffer: function(blob, cb){\n\t    var fr = new FileReader();\n\t    fr.onload = function(evt) {\n\t      cb(evt.target.result);\n\t    };\n\t    fr.readAsArrayBuffer(blob);\n\t  },\n\t  blobToBinaryString: function(blob, cb){\n\t    var fr = new FileReader();\n\t    fr.onload = function(evt) {\n\t      cb(evt.target.result);\n\t    };\n\t    fr.readAsBinaryString(blob);\n\t  },\n\t  binaryStringToArrayBuffer: function(binary) {\n\t    var byteArray = new Uint8Array(binary.length);\n\t    for (var i = 0; i < binary.length; i++) {\n\t      byteArray[i] = binary.charCodeAt(i) & 0xff;\n\t    }\n\t    return byteArray.buffer;\n\t  },\n\t  randomToken: function () {\n\t    return Math.random().toString(36).substr(2);\n\t  },\n\t  //\n\t\n\t  isSecure: function() {\n\t    return location.protocol === 'https:';\n\t  }\n\t};\n\t\n\tmodule.exports = util;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports.RTCSessionDescription = window.RTCSessionDescription ||\n\t\twindow.mozRTCSessionDescription;\n\tmodule.exports.RTCPeerConnection = window.RTCPeerConnection ||\n\t\twindow.mozRTCPeerConnection || window.webkitRTCPeerConnection;\n\tmodule.exports.RTCIceCandidate = window.RTCIceCandidate ||\n\t\twindow.mozRTCIceCandidate;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Representation of a single EventEmitter function.\n\t *\n\t * @param {Function} fn Event handler to be called.\n\t * @param {Mixed} context Context for function execution.\n\t * @param {Boolean} once Only emit once\n\t * @api private\n\t */\n\tfunction EE(fn, context, once) {\n\t  this.fn = fn;\n\t  this.context = context;\n\t  this.once = once || false;\n\t}\n\t\n\t/**\n\t * Minimal EventEmitter interface that is molded against the Node.js\n\t * EventEmitter interface.\n\t *\n\t * @constructor\n\t * @api public\n\t */\n\tfunction EventEmitter() { /* Nothing to set */ }\n\t\n\t/**\n\t * Holds the assigned EventEmitters by name.\n\t *\n\t * @type {Object}\n\t * @private\n\t */\n\tEventEmitter.prototype._events = undefined;\n\t\n\t/**\n\t * Return a list of assigned event listeners.\n\t *\n\t * @param {String} event The events that should be listed.\n\t * @returns {Array}\n\t * @api public\n\t */\n\tEventEmitter.prototype.listeners = function listeners(event) {\n\t  if (!this._events || !this._events[event]) return [];\n\t  if (this._events[event].fn) return [this._events[event].fn];\n\t\n\t  for (var i = 0, l = this._events[event].length, ee = new Array(l); i < l; i++) {\n\t    ee[i] = this._events[event][i].fn;\n\t  }\n\t\n\t  return ee;\n\t};\n\t\n\t/**\n\t * Emit an event to all registered event listeners.\n\t *\n\t * @param {String} event The name of the event.\n\t * @returns {Boolean} Indication if we've emitted an event.\n\t * @api public\n\t */\n\tEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n\t  if (!this._events || !this._events[event]) return false;\n\t\n\t  var listeners = this._events[event]\n\t    , len = arguments.length\n\t    , args\n\t    , i;\n\t\n\t  if ('function' === typeof listeners.fn) {\n\t    if (listeners.once) this.removeListener(event, listeners.fn, true);\n\t\n\t    switch (len) {\n\t      case 1: return listeners.fn.call(listeners.context), true;\n\t      case 2: return listeners.fn.call(listeners.context, a1), true;\n\t      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n\t      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\t      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\t      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n\t    }\n\t\n\t    for (i = 1, args = new Array(len -1); i < len; i++) {\n\t      args[i - 1] = arguments[i];\n\t    }\n\t\n\t    listeners.fn.apply(listeners.context, args);\n\t  } else {\n\t    var length = listeners.length\n\t      , j;\n\t\n\t    for (i = 0; i < length; i++) {\n\t      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);\n\t\n\t      switch (len) {\n\t        case 1: listeners[i].fn.call(listeners[i].context); break;\n\t        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n\t        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n\t        default:\n\t          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n\t            args[j - 1] = arguments[j];\n\t          }\n\t\n\t          listeners[i].fn.apply(listeners[i].context, args);\n\t      }\n\t    }\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\t/**\n\t * Register a new EventListener for the given event.\n\t *\n\t * @param {String} event Name of the event.\n\t * @param {Functon} fn Callback function.\n\t * @param {Mixed} context The context of the function.\n\t * @api public\n\t */\n\tEventEmitter.prototype.on = function on(event, fn, context) {\n\t  var listener = new EE(fn, context || this);\n\t\n\t  if (!this._events) this._events = {};\n\t  if (!this._events[event]) this._events[event] = listener;\n\t  else {\n\t    if (!this._events[event].fn) this._events[event].push(listener);\n\t    else this._events[event] = [\n\t      this._events[event], listener\n\t    ];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add an EventListener that's only called once.\n\t *\n\t * @param {String} event Name of the event.\n\t * @param {Function} fn Callback function.\n\t * @param {Mixed} context The context of the function.\n\t * @api public\n\t */\n\tEventEmitter.prototype.once = function once(event, fn, context) {\n\t  var listener = new EE(fn, context || this, true);\n\t\n\t  if (!this._events) this._events = {};\n\t  if (!this._events[event]) this._events[event] = listener;\n\t  else {\n\t    if (!this._events[event].fn) this._events[event].push(listener);\n\t    else this._events[event] = [\n\t      this._events[event], listener\n\t    ];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove event listeners.\n\t *\n\t * @param {String} event The event we want to remove.\n\t * @param {Function} fn The listener that we need to find.\n\t * @param {Boolean} once Only remove once listeners.\n\t * @api public\n\t */\n\tEventEmitter.prototype.removeListener = function removeListener(event, fn, once) {\n\t  if (!this._events || !this._events[event]) return this;\n\t\n\t  var listeners = this._events[event]\n\t    , events = [];\n\t\n\t  if (fn) {\n\t    if (listeners.fn && (listeners.fn !== fn || (once && !listeners.once))) {\n\t      events.push(listeners);\n\t    }\n\t    if (!listeners.fn) for (var i = 0, length = listeners.length; i < length; i++) {\n\t      if (listeners[i].fn !== fn || (once && !listeners[i].once)) {\n\t        events.push(listeners[i]);\n\t      }\n\t    }\n\t  }\n\t\n\t  //\n\t  // Reset the array, or remove it completely if we have no more listeners.\n\t  //\n\t  if (events.length) {\n\t    this._events[event] = events.length === 1 ? events[0] : events;\n\t  } else {\n\t    delete this._events[event];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove all listeners or only the listeners for the specified event.\n\t *\n\t * @param {String} event The event want to remove all listeners for.\n\t * @api public\n\t */\n\tEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n\t  if (!this._events) return this;\n\t\n\t  if (event) delete this._events[event];\n\t  else this._events = {};\n\t\n\t  return this;\n\t};\n\t\n\t//\n\t// Alias methods names because people roll like that.\n\t//\n\tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\tEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\t\n\t//\n\t// This function doesn't apply anymore.\n\t//\n\tEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n\t  return this;\n\t};\n\t\n\t//\n\t// Expose the module.\n\t//\n\tEventEmitter.EventEmitter = EventEmitter;\n\tEventEmitter.EventEmitter2 = EventEmitter;\n\tEventEmitter.EventEmitter3 = EventEmitter;\n\t\n\t//\n\t// Expose the module.\n\t//\n\tmodule.exports = EventEmitter;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar BufferBuilder = __webpack_require__(5).BufferBuilder;\r\n\tvar binaryFeatures = __webpack_require__(5).binaryFeatures;\r\n\t\r\n\tvar BinaryPack = {\r\n\t  unpack: function(data){\r\n\t    var unpacker = new Unpacker(data);\r\n\t    return unpacker.unpack();\r\n\t  },\r\n\t  pack: function(data){\r\n\t    var packer = new Packer();\r\n\t    packer.pack(data);\r\n\t    var buffer = packer.getBuffer();\r\n\t    return buffer;\r\n\t  }\r\n\t};\r\n\t\r\n\tmodule.exports = BinaryPack;\r\n\t\r\n\tfunction Unpacker (data){\r\n\t  // Data is ArrayBuffer\r\n\t  this.index = 0;\r\n\t  this.dataBuffer = data;\r\n\t  this.dataView = new Uint8Array(this.dataBuffer);\r\n\t  this.length = this.dataBuffer.byteLength;\r\n\t}\r\n\t\r\n\tUnpacker.prototype.unpack = function(){\r\n\t  var type = this.unpack_uint8();\r\n\t  if (type < 0x80){\r\n\t    var positive_fixnum = type;\r\n\t    return positive_fixnum;\r\n\t  } else if ((type ^ 0xe0) < 0x20){\r\n\t    var negative_fixnum = (type ^ 0xe0) - 0x20;\r\n\t    return negative_fixnum;\r\n\t  }\r\n\t  var size;\r\n\t  if ((size = type ^ 0xa0) <= 0x0f){\r\n\t    return this.unpack_raw(size);\r\n\t  } else if ((size = type ^ 0xb0) <= 0x0f){\r\n\t    return this.unpack_string(size);\r\n\t  } else if ((size = type ^ 0x90) <= 0x0f){\r\n\t    return this.unpack_array(size);\r\n\t  } else if ((size = type ^ 0x80) <= 0x0f){\r\n\t    return this.unpack_map(size);\r\n\t  }\r\n\t  switch(type){\r\n\t    case 0xc0:\r\n\t      return null;\r\n\t    case 0xc1:\r\n\t      return undefined;\r\n\t    case 0xc2:\r\n\t      return false;\r\n\t    case 0xc3:\r\n\t      return true;\r\n\t    case 0xca:\r\n\t      return this.unpack_float();\r\n\t    case 0xcb:\r\n\t      return this.unpack_double();\r\n\t    case 0xcc:\r\n\t      return this.unpack_uint8();\r\n\t    case 0xcd:\r\n\t      return this.unpack_uint16();\r\n\t    case 0xce:\r\n\t      return this.unpack_uint32();\r\n\t    case 0xcf:\r\n\t      return this.unpack_uint64();\r\n\t    case 0xd0:\r\n\t      return this.unpack_int8();\r\n\t    case 0xd1:\r\n\t      return this.unpack_int16();\r\n\t    case 0xd2:\r\n\t      return this.unpack_int32();\r\n\t    case 0xd3:\r\n\t      return this.unpack_int64();\r\n\t    case 0xd4:\r\n\t      return undefined;\r\n\t    case 0xd5:\r\n\t      return undefined;\r\n\t    case 0xd6:\r\n\t      return undefined;\r\n\t    case 0xd7:\r\n\t      return undefined;\r\n\t    case 0xd8:\r\n\t      size = this.unpack_uint16();\r\n\t      return this.unpack_string(size);\r\n\t    case 0xd9:\r\n\t      size = this.unpack_uint32();\r\n\t      return this.unpack_string(size);\r\n\t    case 0xda:\r\n\t      size = this.unpack_uint16();\r\n\t      return this.unpack_raw(size);\r\n\t    case 0xdb:\r\n\t      size = this.unpack_uint32();\r\n\t      return this.unpack_raw(size);\r\n\t    case 0xdc:\r\n\t      size = this.unpack_uint16();\r\n\t      return this.unpack_array(size);\r\n\t    case 0xdd:\r\n\t      size = this.unpack_uint32();\r\n\t      return this.unpack_array(size);\r\n\t    case 0xde:\r\n\t      size = this.unpack_uint16();\r\n\t      return this.unpack_map(size);\r\n\t    case 0xdf:\r\n\t      size = this.unpack_uint32();\r\n\t      return this.unpack_map(size);\r\n\t  }\r\n\t}\r\n\t\r\n\tUnpacker.prototype.unpack_uint8 = function(){\r\n\t  var byte = this.dataView[this.index] & 0xff;\r\n\t  this.index++;\r\n\t  return byte;\r\n\t};\r\n\t\r\n\tUnpacker.prototype.unpack_uint16 = function(){\r\n\t  var bytes = this.read(2);\r\n\t  var uint16 =\r\n\t    ((bytes[0] & 0xff) * 256) + (bytes[1] & 0xff);\r\n\t  this.index += 2;\r\n\t  return uint16;\r\n\t}\r\n\t\r\n\tUnpacker.prototype.unpack_uint32 = function(){\r\n\t  var bytes = this.read(4);\r\n\t  var uint32 =\r\n\t     ((bytes[0]  * 256 +\r\n\t       bytes[1]) * 256 +\r\n\t       bytes[2]) * 256 +\r\n\t       bytes[3];\r\n\t  this.index += 4;\r\n\t  return uint32;\r\n\t}\r\n\t\r\n\tUnpacker.prototype.unpack_uint64 = function(){\r\n\t  var bytes = this.read(8);\r\n\t  var uint64 =\r\n\t   ((((((bytes[0]  * 256 +\r\n\t       bytes[1]) * 256 +\r\n\t       bytes[2]) * 256 +\r\n\t       bytes[3]) * 256 +\r\n\t       bytes[4]) * 256 +\r\n\t       bytes[5]) * 256 +\r\n\t       bytes[6]) * 256 +\r\n\t       bytes[7];\r\n\t  this.index += 8;\r\n\t  return uint64;\r\n\t}\r\n\t\r\n\t\r\n\tUnpacker.prototype.unpack_int8 = function(){\r\n\t  var uint8 = this.unpack_uint8();\r\n\t  return (uint8 < 0x80 ) ? uint8 : uint8 - (1 << 8);\r\n\t};\r\n\t\r\n\tUnpacker.prototype.unpack_int16 = function(){\r\n\t  var uint16 = this.unpack_uint16();\r\n\t  return (uint16 < 0x8000 ) ? uint16 : uint16 - (1 << 16);\r\n\t}\r\n\t\r\n\tUnpacker.prototype.unpack_int32 = function(){\r\n\t  var uint32 = this.unpack_uint32();\r\n\t  return (uint32 < Math.pow(2, 31) ) ? uint32 :\r\n\t    uint32 - Math.pow(2, 32);\r\n\t}\r\n\t\r\n\tUnpacker.prototype.unpack_int64 = function(){\r\n\t  var uint64 = this.unpack_uint64();\r\n\t  return (uint64 < Math.pow(2, 63) ) ? uint64 :\r\n\t    uint64 - Math.pow(2, 64);\r\n\t}\r\n\t\r\n\tUnpacker.prototype.unpack_raw = function(size){\r\n\t  if ( this.length < this.index + size){\r\n\t    throw new Error('BinaryPackFailure: index is out of range'\r\n\t      + ' ' + this.index + ' ' + size + ' ' + this.length);\r\n\t  }\r\n\t  var buf = this.dataBuffer.slice(this.index, this.index + size);\r\n\t  this.index += size;\r\n\t\r\n\t    //buf = util.bufferToString(buf);\r\n\t\r\n\t  return buf;\r\n\t}\r\n\t\r\n\tUnpacker.prototype.unpack_string = function(size){\r\n\t  var bytes = this.read(size);\r\n\t  var i = 0, str = '', c, code;\r\n\t  while(i < size){\r\n\t    c = bytes[i];\r\n\t    if ( c < 128){\r\n\t      str += String.fromCharCode(c);\r\n\t      i++;\r\n\t    } else if ((c ^ 0xc0) < 32){\r\n\t      code = ((c ^ 0xc0) << 6) | (bytes[i+1] & 63);\r\n\t      str += String.fromCharCode(code);\r\n\t      i += 2;\r\n\t    } else {\r\n\t      code = ((c & 15) << 12) | ((bytes[i+1] & 63) << 6) |\r\n\t        (bytes[i+2] & 63);\r\n\t      str += String.fromCharCode(code);\r\n\t      i += 3;\r\n\t    }\r\n\t  }\r\n\t  this.index += size;\r\n\t  return str;\r\n\t}\r\n\t\r\n\tUnpacker.prototype.unpack_array = function(size){\r\n\t  var objects = new Array(size);\r\n\t  for(var i = 0; i < size ; i++){\r\n\t    objects[i] = this.unpack();\r\n\t  }\r\n\t  return objects;\r\n\t}\r\n\t\r\n\tUnpacker.prototype.unpack_map = function(size){\r\n\t  var map = {};\r\n\t  for(var i = 0; i < size ; i++){\r\n\t    var key  = this.unpack();\r\n\t    var value = this.unpack();\r\n\t    map[key] = value;\r\n\t  }\r\n\t  return map;\r\n\t}\r\n\t\r\n\tUnpacker.prototype.unpack_float = function(){\r\n\t  var uint32 = this.unpack_uint32();\r\n\t  var sign = uint32 >> 31;\r\n\t  var exp  = ((uint32 >> 23) & 0xff) - 127;\r\n\t  var fraction = ( uint32 & 0x7fffff ) | 0x800000;\r\n\t  return (sign == 0 ? 1 : -1) *\r\n\t    fraction * Math.pow(2, exp - 23);\r\n\t}\r\n\t\r\n\tUnpacker.prototype.unpack_double = function(){\r\n\t  var h32 = this.unpack_uint32();\r\n\t  var l32 = this.unpack_uint32();\r\n\t  var sign = h32 >> 31;\r\n\t  var exp  = ((h32 >> 20) & 0x7ff) - 1023;\r\n\t  var hfrac = ( h32 & 0xfffff ) | 0x100000;\r\n\t  var frac = hfrac * Math.pow(2, exp - 20) +\r\n\t    l32   * Math.pow(2, exp - 52);\r\n\t  return (sign == 0 ? 1 : -1) * frac;\r\n\t}\r\n\t\r\n\tUnpacker.prototype.read = function(length){\r\n\t  var j = this.index;\r\n\t  if (j + length <= this.length) {\r\n\t    return this.dataView.subarray(j, j + length);\r\n\t  } else {\r\n\t    throw new Error('BinaryPackFailure: read index out of range');\r\n\t  }\r\n\t}\r\n\t\r\n\tfunction Packer(){\r\n\t  this.bufferBuilder = new BufferBuilder();\r\n\t}\r\n\t\r\n\tPacker.prototype.getBuffer = function(){\r\n\t  return this.bufferBuilder.getBuffer();\r\n\t}\r\n\t\r\n\tPacker.prototype.pack = function(value){\r\n\t  var type = typeof(value);\r\n\t  if (type == 'string'){\r\n\t    this.pack_string(value);\r\n\t  } else if (type == 'number'){\r\n\t    if (Math.floor(value) === value){\r\n\t      this.pack_integer(value);\r\n\t    } else{\r\n\t      this.pack_double(value);\r\n\t    }\r\n\t  } else if (type == 'boolean'){\r\n\t    if (value === true){\r\n\t      this.bufferBuilder.append(0xc3);\r\n\t    } else if (value === false){\r\n\t      this.bufferBuilder.append(0xc2);\r\n\t    }\r\n\t  } else if (type == 'undefined'){\r\n\t    this.bufferBuilder.append(0xc0);\r\n\t  } else if (type == 'object'){\r\n\t    if (value === null){\r\n\t      this.bufferBuilder.append(0xc0);\r\n\t    } else {\r\n\t      var constructor = value.constructor;\r\n\t      if (constructor == Array){\r\n\t        this.pack_array(value);\r\n\t      } else if (constructor == Blob || constructor == File) {\r\n\t        this.pack_bin(value);\r\n\t      } else if (constructor == ArrayBuffer) {\r\n\t        if(binaryFeatures.useArrayBufferView) {\r\n\t          this.pack_bin(new Uint8Array(value));\r\n\t        } else {\r\n\t          this.pack_bin(value);\r\n\t        }\r\n\t      } else if ('BYTES_PER_ELEMENT' in value){\r\n\t        if(binaryFeatures.useArrayBufferView) {\r\n\t          this.pack_bin(new Uint8Array(value.buffer));\r\n\t        } else {\r\n\t          this.pack_bin(value.buffer);\r\n\t        }\r\n\t      } else if (constructor == Object){\r\n\t        this.pack_object(value);\r\n\t      } else if (constructor == Date){\r\n\t        this.pack_string(value.toString());\r\n\t      } else if (typeof value.toBinaryPack == 'function'){\r\n\t        this.bufferBuilder.append(value.toBinaryPack());\r\n\t      } else {\r\n\t        throw new Error('Type \"' + constructor.toString() + '\" not yet supported');\r\n\t      }\r\n\t    }\r\n\t  } else {\r\n\t    throw new Error('Type \"' + type + '\" not yet supported');\r\n\t  }\r\n\t  this.bufferBuilder.flush();\r\n\t}\r\n\t\r\n\t\r\n\tPacker.prototype.pack_bin = function(blob){\r\n\t  var length = blob.length || blob.byteLength || blob.size;\r\n\t  if (length <= 0x0f){\r\n\t    this.pack_uint8(0xa0 + length);\r\n\t  } else if (length <= 0xffff){\r\n\t    this.bufferBuilder.append(0xda) ;\r\n\t    this.pack_uint16(length);\r\n\t  } else if (length <= 0xffffffff){\r\n\t    this.bufferBuilder.append(0xdb);\r\n\t    this.pack_uint32(length);\r\n\t  } else{\r\n\t    throw new Error('Invalid length');\r\n\t  }\r\n\t  this.bufferBuilder.append(blob);\r\n\t}\r\n\t\r\n\tPacker.prototype.pack_string = function(str){\r\n\t  var length = utf8Length(str);\r\n\t\r\n\t  if (length <= 0x0f){\r\n\t    this.pack_uint8(0xb0 + length);\r\n\t  } else if (length <= 0xffff){\r\n\t    this.bufferBuilder.append(0xd8) ;\r\n\t    this.pack_uint16(length);\r\n\t  } else if (length <= 0xffffffff){\r\n\t    this.bufferBuilder.append(0xd9);\r\n\t    this.pack_uint32(length);\r\n\t  } else{\r\n\t    throw new Error('Invalid length');\r\n\t  }\r\n\t  this.bufferBuilder.append(str);\r\n\t}\r\n\t\r\n\tPacker.prototype.pack_array = function(ary){\r\n\t  var length = ary.length;\r\n\t  if (length <= 0x0f){\r\n\t    this.pack_uint8(0x90 + length);\r\n\t  } else if (length <= 0xffff){\r\n\t    this.bufferBuilder.append(0xdc)\r\n\t    this.pack_uint16(length);\r\n\t  } else if (length <= 0xffffffff){\r\n\t    this.bufferBuilder.append(0xdd);\r\n\t    this.pack_uint32(length);\r\n\t  } else{\r\n\t    throw new Error('Invalid length');\r\n\t  }\r\n\t  for(var i = 0; i < length ; i++){\r\n\t    this.pack(ary[i]);\r\n\t  }\r\n\t}\r\n\t\r\n\tPacker.prototype.pack_integer = function(num){\r\n\t  if ( -0x20 <= num && num <= 0x7f){\r\n\t    this.bufferBuilder.append(num & 0xff);\r\n\t  } else if (0x00 <= num && num <= 0xff){\r\n\t    this.bufferBuilder.append(0xcc);\r\n\t    this.pack_uint8(num);\r\n\t  } else if (-0x80 <= num && num <= 0x7f){\r\n\t    this.bufferBuilder.append(0xd0);\r\n\t    this.pack_int8(num);\r\n\t  } else if ( 0x0000 <= num && num <= 0xffff){\r\n\t    this.bufferBuilder.append(0xcd);\r\n\t    this.pack_uint16(num);\r\n\t  } else if (-0x8000 <= num && num <= 0x7fff){\r\n\t    this.bufferBuilder.append(0xd1);\r\n\t    this.pack_int16(num);\r\n\t  } else if ( 0x00000000 <= num && num <= 0xffffffff){\r\n\t    this.bufferBuilder.append(0xce);\r\n\t    this.pack_uint32(num);\r\n\t  } else if (-0x80000000 <= num && num <= 0x7fffffff){\r\n\t    this.bufferBuilder.append(0xd2);\r\n\t    this.pack_int32(num);\r\n\t  } else if (-0x8000000000000000 <= num && num <= 0x7FFFFFFFFFFFFFFF){\r\n\t    this.bufferBuilder.append(0xd3);\r\n\t    this.pack_int64(num);\r\n\t  } else if (0x0000000000000000 <= num && num <= 0xFFFFFFFFFFFFFFFF){\r\n\t    this.bufferBuilder.append(0xcf);\r\n\t    this.pack_uint64(num);\r\n\t  } else{\r\n\t    throw new Error('Invalid integer');\r\n\t  }\r\n\t}\r\n\t\r\n\tPacker.prototype.pack_double = function(num){\r\n\t  var sign = 0;\r\n\t  if (num < 0){\r\n\t    sign = 1;\r\n\t    num = -num;\r\n\t  }\r\n\t  var exp  = Math.floor(Math.log(num) / Math.LN2);\r\n\t  var frac0 = num / Math.pow(2, exp) - 1;\r\n\t  var frac1 = Math.floor(frac0 * Math.pow(2, 52));\r\n\t  var b32   = Math.pow(2, 32);\r\n\t  var h32 = (sign << 31) | ((exp+1023) << 20) |\r\n\t      (frac1 / b32) & 0x0fffff;\r\n\t  var l32 = frac1 % b32;\r\n\t  this.bufferBuilder.append(0xcb);\r\n\t  this.pack_int32(h32);\r\n\t  this.pack_int32(l32);\r\n\t}\r\n\t\r\n\tPacker.prototype.pack_object = function(obj){\r\n\t  var keys = Object.keys(obj);\r\n\t  var length = keys.length;\r\n\t  if (length <= 0x0f){\r\n\t    this.pack_uint8(0x80 + length);\r\n\t  } else if (length <= 0xffff){\r\n\t    this.bufferBuilder.append(0xde);\r\n\t    this.pack_uint16(length);\r\n\t  } else if (length <= 0xffffffff){\r\n\t    this.bufferBuilder.append(0xdf);\r\n\t    this.pack_uint32(length);\r\n\t  } else{\r\n\t    throw new Error('Invalid length');\r\n\t  }\r\n\t  for(var prop in obj){\r\n\t    if (obj.hasOwnProperty(prop)){\r\n\t      this.pack(prop);\r\n\t      this.pack(obj[prop]);\r\n\t    }\r\n\t  }\r\n\t}\r\n\t\r\n\tPacker.prototype.pack_uint8 = function(num){\r\n\t  this.bufferBuilder.append(num);\r\n\t}\r\n\t\r\n\tPacker.prototype.pack_uint16 = function(num){\r\n\t  this.bufferBuilder.append(num >> 8);\r\n\t  this.bufferBuilder.append(num & 0xff);\r\n\t}\r\n\t\r\n\tPacker.prototype.pack_uint32 = function(num){\r\n\t  var n = num & 0xffffffff;\r\n\t  this.bufferBuilder.append((n & 0xff000000) >>> 24);\r\n\t  this.bufferBuilder.append((n & 0x00ff0000) >>> 16);\r\n\t  this.bufferBuilder.append((n & 0x0000ff00) >>>  8);\r\n\t  this.bufferBuilder.append((n & 0x000000ff));\r\n\t}\r\n\t\r\n\tPacker.prototype.pack_uint64 = function(num){\r\n\t  var high = num / Math.pow(2, 32);\r\n\t  var low  = num % Math.pow(2, 32);\r\n\t  this.bufferBuilder.append((high & 0xff000000) >>> 24);\r\n\t  this.bufferBuilder.append((high & 0x00ff0000) >>> 16);\r\n\t  this.bufferBuilder.append((high & 0x0000ff00) >>>  8);\r\n\t  this.bufferBuilder.append((high & 0x000000ff));\r\n\t  this.bufferBuilder.append((low  & 0xff000000) >>> 24);\r\n\t  this.bufferBuilder.append((low  & 0x00ff0000) >>> 16);\r\n\t  this.bufferBuilder.append((low  & 0x0000ff00) >>>  8);\r\n\t  this.bufferBuilder.append((low  & 0x000000ff));\r\n\t}\r\n\t\r\n\tPacker.prototype.pack_int8 = function(num){\r\n\t  this.bufferBuilder.append(num & 0xff);\r\n\t}\r\n\t\r\n\tPacker.prototype.pack_int16 = function(num){\r\n\t  this.bufferBuilder.append((num & 0xff00) >> 8);\r\n\t  this.bufferBuilder.append(num & 0xff);\r\n\t}\r\n\t\r\n\tPacker.prototype.pack_int32 = function(num){\r\n\t  this.bufferBuilder.append((num >>> 24) & 0xff);\r\n\t  this.bufferBuilder.append((num & 0x00ff0000) >>> 16);\r\n\t  this.bufferBuilder.append((num & 0x0000ff00) >>> 8);\r\n\t  this.bufferBuilder.append((num & 0x000000ff));\r\n\t}\r\n\t\r\n\tPacker.prototype.pack_int64 = function(num){\r\n\t  var high = Math.floor(num / Math.pow(2, 32));\r\n\t  var low  = num % Math.pow(2, 32);\r\n\t  this.bufferBuilder.append((high & 0xff000000) >>> 24);\r\n\t  this.bufferBuilder.append((high & 0x00ff0000) >>> 16);\r\n\t  this.bufferBuilder.append((high & 0x0000ff00) >>>  8);\r\n\t  this.bufferBuilder.append((high & 0x000000ff));\r\n\t  this.bufferBuilder.append((low  & 0xff000000) >>> 24);\r\n\t  this.bufferBuilder.append((low  & 0x00ff0000) >>> 16);\r\n\t  this.bufferBuilder.append((low  & 0x0000ff00) >>>  8);\r\n\t  this.bufferBuilder.append((low  & 0x000000ff));\r\n\t}\r\n\t\r\n\tfunction _utf8Replace(m){\r\n\t  var code = m.charCodeAt(0);\r\n\t\r\n\t  if(code <= 0x7ff) return '00';\r\n\t  if(code <= 0xffff) return '000';\r\n\t  if(code <= 0x1fffff) return '0000';\r\n\t  if(code <= 0x3ffffff) return '00000';\r\n\t  return '000000';\r\n\t}\r\n\t\r\n\tfunction utf8Length(str){\r\n\t  if (str.length > 600) {\r\n\t    // Blob method faster for large strings\r\n\t    return (new Blob([str])).size;\r\n\t  } else {\r\n\t    return str.replace(/[^\\u0000-\\u007F]/g, _utf8Replace).length;\r\n\t  }\r\n\t}\r\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tvar binaryFeatures = {};\r\n\tbinaryFeatures.useBlobBuilder = (function(){\r\n\t  try {\r\n\t    new Blob([]);\r\n\t    return false;\r\n\t  } catch (e) {\r\n\t    return true;\r\n\t  }\r\n\t})();\r\n\t\r\n\tbinaryFeatures.useArrayBufferView = !binaryFeatures.useBlobBuilder && (function(){\r\n\t  try {\r\n\t    return (new Blob([new Uint8Array([])])).size === 0;\r\n\t  } catch (e) {\r\n\t    return true;\r\n\t  }\r\n\t})();\r\n\t\r\n\tmodule.exports.binaryFeatures = binaryFeatures;\r\n\tvar BlobBuilder = module.exports.BlobBuilder;\r\n\tif (typeof window != 'undefined') {\r\n\t  BlobBuilder = module.exports.BlobBuilder = window.WebKitBlobBuilder ||\r\n\t    window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder;\r\n\t}\r\n\t\r\n\tfunction BufferBuilder(){\r\n\t  this._pieces = [];\r\n\t  this._parts = [];\r\n\t}\r\n\t\r\n\tBufferBuilder.prototype.append = function(data) {\r\n\t  if(typeof data === 'number') {\r\n\t    this._pieces.push(data);\r\n\t  } else {\r\n\t    this.flush();\r\n\t    this._parts.push(data);\r\n\t  }\r\n\t};\r\n\t\r\n\tBufferBuilder.prototype.flush = function() {\r\n\t  if (this._pieces.length > 0) {\r\n\t    var buf = new Uint8Array(this._pieces);\r\n\t    if(!binaryFeatures.useArrayBufferView) {\r\n\t      buf = buf.buffer;\r\n\t    }\r\n\t    this._parts.push(buf);\r\n\t    this._pieces = [];\r\n\t  }\r\n\t};\r\n\t\r\n\tBufferBuilder.prototype.getBuffer = function() {\r\n\t  this.flush();\r\n\t  if(binaryFeatures.useBlobBuilder) {\r\n\t    var builder = new BlobBuilder();\r\n\t    for(var i = 0, ii = this._parts.length; i < ii; i++) {\r\n\t      builder.append(this._parts[i]);\r\n\t    }\r\n\t    return builder.getBlob();\r\n\t  } else {\r\n\t    return new Blob(this._parts);\r\n\t  }\r\n\t};\r\n\t\r\n\tmodule.exports.BufferBuilder = BufferBuilder;\r\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(1);\n\tvar RTCPeerConnection = __webpack_require__(2).RTCPeerConnection;\n\tvar RTCSessionDescription = __webpack_require__(2).RTCSessionDescription;\n\tvar RTCIceCandidate = __webpack_require__(2).RTCIceCandidate;\n\t\n\t/**\n\t * Manages all negotiations between Peers.\n\t */\n\tvar Negotiator = {\n\t  pcs: {\n\t    data: {},\n\t    media: {}\n\t  }, // type => {peerId: {pc_id: pc}}.\n\t  //providers: {}, // provider's id => providers (there may be multiple providers/client.\n\t  queue: [] // connections that are delayed due to a PC being in use.\n\t}\n\t\n\tNegotiator._idPrefix = 'pc_';\n\t\n\t/** Returns a PeerConnection object set up correctly (for data, media). */\n\tNegotiator.startConnection = function(connection, options) {\n\t  var pc = Negotiator._getPeerConnection(connection, options);\n\t\n\t  if (connection.type === 'media' && options._stream) {\n\t    // Add the stream.\n\t    pc.addStream(options._stream);\n\t  }\n\t\n\t  // Set the connection's PC.\n\t  connection.pc = connection.peerConnection = pc;\n\t  // What do we need to do now?\n\t  if (options.originator) {\n\t    if (connection.type === 'data') {\n\t      // Create the datachannel.\n\t      var config = {};\n\t      // Dropping reliable:false support, since it seems to be crashing\n\t      // Chrome.\n\t      /*if (util.supports.sctp && !options.reliable) {\n\t        // If we have canonical reliable support...\n\t        config = {maxRetransmits: 0};\n\t      }*/\n\t      // Fallback to ensure older browsers don't crash.\n\t      if (!util.supports.sctp) {\n\t        config = {reliable: options.reliable};\n\t      }\n\t      var dc = pc.createDataChannel(connection.label, config);\n\t      connection.initialize(dc);\n\t    }\n\t\n\t    if (!util.supports.onnegotiationneeded) {\n\t      Negotiator._makeOffer(connection);\n\t    }\n\t  } else {\n\t    Negotiator.handleSDP('OFFER', connection, options.sdp);\n\t  }\n\t}\n\t\n\tNegotiator._getPeerConnection = function(connection, options) {\n\t  if (!Negotiator.pcs[connection.type]) {\n\t    util.error(connection.type + ' is not a valid connection type. Maybe you overrode the `type` property somewhere.');\n\t  }\n\t\n\t  if (!Negotiator.pcs[connection.type][connection.peer]) {\n\t    Negotiator.pcs[connection.type][connection.peer] = {};\n\t  }\n\t  var peerConnections = Negotiator.pcs[connection.type][connection.peer];\n\t\n\t  var pc;\n\t  // Not multiplexing while FF and Chrome have not-great support for it.\n\t  /*if (options.multiplex) {\n\t    ids = Object.keys(peerConnections);\n\t    for (var i = 0, ii = ids.length; i < ii; i += 1) {\n\t      pc = peerConnections[ids[i]];\n\t      if (pc.signalingState === 'stable') {\n\t        break; // We can go ahead and use this PC.\n\t      }\n\t    }\n\t  } else */\n\t  if (options.pc) { // Simplest case: PC id already provided for us.\n\t    pc = Negotiator.pcs[connection.type][connection.peer][options.pc];\n\t  }\n\t\n\t  if (!pc || pc.signalingState !== 'stable') {\n\t    pc = Negotiator._startPeerConnection(connection);\n\t  }\n\t  return pc;\n\t}\n\t\n\t/*\n\tNegotiator._addProvider = function(provider) {\n\t  if ((!provider.id && !provider.disconnected) || !provider.socket.open) {\n\t    // Wait for provider to obtain an ID.\n\t    provider.on('open', function(id) {\n\t      Negotiator._addProvider(provider);\n\t    });\n\t  } else {\n\t    Negotiator.providers[provider.id] = provider;\n\t  }\n\t}*/\n\t\n\t\n\t/** Start a PC. */\n\tNegotiator._startPeerConnection = function(connection) {\n\t  util.log('Creating RTCPeerConnection.');\n\t\n\t  var id = Negotiator._idPrefix + util.randomToken();\n\t  var optional = {};\n\t\n\t  if (connection.type === 'data' && !util.supports.sctp) {\n\t    optional = {optional: [{RtpDataChannels: true}]};\n\t  } else if (connection.type === 'media') {\n\t    // Interop req for chrome.\n\t    optional = {optional: [{DtlsSrtpKeyAgreement: true}]};\n\t  }\n\t\n\t  var pc = new RTCPeerConnection(connection.provider.options.config, optional);\n\t  Negotiator.pcs[connection.type][connection.peer][id] = pc;\n\t\n\t  Negotiator._setupListeners(connection, pc, id);\n\t\n\t  return pc;\n\t}\n\t\n\t/** Set up various WebRTC listeners. */\n\tNegotiator._setupListeners = function(connection, pc, pc_id) {\n\t  var peerId = connection.peer;\n\t  var connectionId = connection.id;\n\t  var provider = connection.provider;\n\t\n\t  // ICE CANDIDATES.\n\t  util.log('Listening for ICE candidates.');\n\t  pc.onicecandidate = function(evt) {\n\t    if (evt.candidate) {\n\t      util.log('Received ICE candidates for:', connection.peer);\n\t      provider.socket.send({\n\t        type: 'CANDIDATE',\n\t        payload: {\n\t          candidate: evt.candidate,\n\t          type: connection.type,\n\t          connectionId: connection.id\n\t        },\n\t        dst: peerId\n\t      });\n\t    }\n\t  };\n\t\n\t  pc.oniceconnectionstatechange = function() {\n\t    switch (pc.iceConnectionState) {\n\t      case 'disconnected':\n\t      case 'failed':\n\t        util.log('iceConnectionState is disconnected, closing connections to ' + peerId);\n\t        connection.close();\n\t        break;\n\t      case 'completed':\n\t        pc.onicecandidate = util.noop;\n\t        break;\n\t    }\n\t  };\n\t\n\t  // Fallback for older Chrome impls.\n\t  pc.onicechange = pc.oniceconnectionstatechange;\n\t\n\t  // ONNEGOTIATIONNEEDED (Chrome)\n\t  util.log('Listening for `negotiationneeded`');\n\t  pc.onnegotiationneeded = function() {\n\t    util.log('`negotiationneeded` triggered');\n\t    if (pc.signalingState == 'stable') {\n\t      Negotiator._makeOffer(connection);\n\t    } else {\n\t      util.log('onnegotiationneeded triggered when not stable. Is another connection being established?');\n\t    }\n\t  };\n\t\n\t  // DATACONNECTION.\n\t  util.log('Listening for data channel');\n\t  // Fired between offer and answer, so options should already be saved\n\t  // in the options hash.\n\t  pc.ondatachannel = function(evt) {\n\t    util.log('Received data channel');\n\t    var dc = evt.channel;\n\t    var connection = provider.getConnection(peerId, connectionId);\n\t    connection.initialize(dc);\n\t  };\n\t\n\t  // MEDIACONNECTION.\n\t  util.log('Listening for remote stream');\n\t  pc.onaddstream = function(evt) {\n\t    util.log('Received remote stream');\n\t    var stream = evt.stream;\n\t    var connection = provider.getConnection(peerId, connectionId);\n\t    // 10/10/2014: looks like in Chrome 38, onaddstream is triggered after\n\t    // setting the remote description. Our connection object in these cases\n\t    // is actually a DATA connection, so addStream fails.\n\t    // TODO: This is hopefully just a temporary fix. We should try to\n\t    // understand why this is happening.\n\t    if (connection.type === 'media') {\n\t      connection.addStream(stream);\n\t    }\n\t  };\n\t}\n\t\n\tNegotiator.cleanup = function(connection) {\n\t  util.log('Cleaning up PeerConnection to ' + connection.peer);\n\t\n\t  var pc = connection.pc;\n\t\n\t  if (!!pc && (pc.readyState !== 'closed' || pc.signalingState !== 'closed')) {\n\t    pc.close();\n\t    connection.pc = null;\n\t  }\n\t}\n\t\n\tNegotiator._makeOffer = function(connection) {\n\t  var pc = connection.pc;\n\t  pc.createOffer(function(offer) {\n\t    util.log('Created offer.');\n\t\n\t    if (!util.supports.sctp && connection.type === 'data' && connection.reliable) {\n\t      offer.sdp = Reliable.higherBandwidthSDP(offer.sdp);\n\t    }\n\t\n\t    pc.setLocalDescription(offer, function() {\n\t      util.log('Set localDescription: offer', 'for:', connection.peer);\n\t      connection.provider.socket.send({\n\t        type: 'OFFER',\n\t        payload: {\n\t          sdp: offer,\n\t          type: connection.type,\n\t          label: connection.label,\n\t          connectionId: connection.id,\n\t          reliable: connection.reliable,\n\t          serialization: connection.serialization,\n\t          metadata: connection.metadata,\n\t          browser: util.browser\n\t        },\n\t        dst: connection.peer\n\t      });\n\t    }, function(err) {\n\t      connection.provider.emitError('webrtc', err);\n\t      util.log('Failed to setLocalDescription, ', err);\n\t    });\n\t  }, function(err) {\n\t    connection.provider.emitError('webrtc', err);\n\t    util.log('Failed to createOffer, ', err);\n\t  }, connection.options.constraints);\n\t}\n\t\n\tNegotiator._makeAnswer = function(connection) {\n\t  var pc = connection.pc;\n\t\n\t  pc.createAnswer(function(answer) {\n\t    util.log('Created answer.');\n\t\n\t    if (!util.supports.sctp && connection.type === 'data' && connection.reliable) {\n\t      answer.sdp = Reliable.higherBandwidthSDP(answer.sdp);\n\t    }\n\t\n\t    pc.setLocalDescription(answer, function() {\n\t      util.log('Set localDescription: answer', 'for:', connection.peer);\n\t      connection.provider.socket.send({\n\t        type: 'ANSWER',\n\t        payload: {\n\t          sdp: answer,\n\t          type: connection.type,\n\t          connectionId: connection.id,\n\t          browser: util.browser\n\t        },\n\t        dst: connection.peer\n\t      });\n\t    }, function(err) {\n\t      connection.provider.emitError('webrtc', err);\n\t      util.log('Failed to setLocalDescription, ', err);\n\t    });\n\t  }, function(err) {\n\t    connection.provider.emitError('webrtc', err);\n\t    util.log('Failed to create answer, ', err);\n\t  });\n\t}\n\t\n\t/** Handle an SDP. */\n\tNegotiator.handleSDP = function(type, connection, sdp) {\n\t  sdp = new RTCSessionDescription(sdp);\n\t  var pc = connection.pc;\n\t\n\t  util.log('Setting remote description', sdp);\n\t  pc.setRemoteDescription(sdp, function() {\n\t    util.log('Set remoteDescription:', type, 'for:', connection.peer);\n\t\n\t    if (type === 'OFFER') {\n\t      Negotiator._makeAnswer(connection);\n\t    }\n\t  }, function(err) {\n\t    connection.provider.emitError('webrtc', err);\n\t    util.log('Failed to setRemoteDescription, ', err);\n\t  });\n\t}\n\t\n\t/** Handle a candidate. */\n\tNegotiator.handleCandidate = function(connection, ice) {\n\t  var candidate = ice.candidate;\n\t  var sdpMLineIndex = ice.sdpMLineIndex;\n\t  connection.pc.addIceCandidate(new RTCIceCandidate({\n\t    sdpMLineIndex: sdpMLineIndex,\n\t    candidate: candidate\n\t  }));\n\t  util.log('Added ICE candidate for:', connection.peer);\n\t}\n\t\n\tmodule.exports = Negotiator;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = PeerWeb;\n\t\n\tvar _peerjs = __webpack_require__(11);\n\t\n\tvar _peerjs2 = _interopRequireDefault(_peerjs);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/* eslint-disable no-console */\n\tfunction PeerWeb(key, existingPeer) {\n\t  var _this = this;\n\t\n\t  if (this.constructor !== PeerWeb) return new PeerWeb(key, existingPeer);\n\t\n\t  // Private Vars\n\t  var peer = existingPeer || new _peerjs2.default({ key: key }); // , debug: 3 });\n\t  this.peer = peer;\n\t  var potentialPeers = [];\n\t  var connections = [];\n\t\n\t  // Private Functions\n\t  function trigger(action) {\n\t    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      args[_key - 1] = arguments[_key];\n\t    }\n\t\n\t    callbacks[action].forEach(function (cb) {\n\t      return cb.apply(null, args);\n\t    });\n\t  }\n\t  function tryPotentialPeers() {\n\t    if (peer.disconnected) return;\n\t    potentialPeers.forEach(function (peerId) {\n\t      setupConnection(peer.connect(peerId));\n\t    });\n\t    potentialPeers.splice(0);\n\t  }\n\t  function setupConnection(connection) {\n\t    connection.on('open', function () {\n\t      connections.push(connection);\n\t      trigger('Connected', connection.peer);\n\t    });\n\t    connection.on('data', trigger.bind(null, 'Data'));\n\t    connection.on('close', function () {\n\t      var index = connections.indexOf(connection);\n\t      if (index === -1) {\n\t        console.log('connection on close not in connections');debugger;return;\n\t      }\n\t      connections.splice(index, 1);\n\t      trigger('Disconnected', connection.peer);\n\t    });\n\t    connection.on('error', function (error) {\n\t      console.log('connection on error', connection, error);debugger;\n\t    });\n\t  }\n\t\n\t  // Initialize\n\t  peer.on('open', function (id) {\n\t    trigger('Open', id);\n\t    tryPotentialPeers();\n\t  });\n\t  peer.on('connection', setupConnection);\n\t  peer.on('close', function () {\n\t    console.log('peer on close', peer);\n\t  }); // lost connections, should call `peer.destroy()`\n\t  peer.on('disconnected', function () {\n\t    trigger('Close');\n\t  }); // no new connections, but keeps existing connections, should call `peer.reconnect()`\n\t  peer.on('error', function (error) {\n\t    var a = {\n\t      'peer-unavailable': function peerUnavailable() {\n\t        trigger('Unavailable', error.message.match(/Could not connect to peer (.+)$/)[1]);\n\t      }\n\t    }[error.type];\n\t    if (a) a(error);else console.error('Unknown peer error: ' + error.type, error);\n\t  });\n\t\n\t  // Public Functions\n\t  this.addPeer = function (peerId) {\n\t    potentialPeers.push(peerId);\n\t    tryPotentialPeers();\n\t  };\n\t  this.send = function () {\n\t    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t      args[_key2] = arguments[_key2];\n\t    }\n\t\n\t    connections.forEach(function (connection) {\n\t      return connection.send.apply(connection, args);\n\t    });\n\t  };\n\t  this.reconnect = peer.reconnect;\n\t  this.destroy = peer.destroy;\n\t  var callbacks = {};\n\t  Object.keys(PeerWeb.actions).forEach(function (action) {\n\t    callbacks[action] = [];\n\t    _this['on' + action] = function (cb) {\n\t      callbacks[action].push(cb);\n\t    };\n\t    _this['off' + action] = function (cb) {\n\t      if (cb) {\n\t        var index = callbacks[action].indexOf(cb);\n\t        if (index === -1) return 0;\n\t        return callbacks[action].splice(index, 1).length;\n\t      } else {\n\t        return callbacks[action].splice(0).length;\n\t      }\n\t    };\n\t  });\n\t}\n\t// Callback API\n\tPeerWeb.actions = {\n\t  'Open': ['peerId'],\n\t  'Connected': ['connectedPeerId'],\n\t  'Data': ['data'],\n\t  'Disconnected': ['connectedPeerId'],\n\t  'Close': [],\n\t  'Unavailable': ['connectedPeerId']\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {module.exports = global[\"PeerWeb\"] = __webpack_require__(7);\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(1);\n\tvar EventEmitter = __webpack_require__(3);\n\tvar Negotiator = __webpack_require__(6);\n\tvar Reliable = __webpack_require__(13);\n\t\n\t/**\n\t * Wraps a DataChannel between two Peers.\n\t */\n\tfunction DataConnection(peer, provider, options) {\n\t  if (!(this instanceof DataConnection)) return new DataConnection(peer, provider, options);\n\t  EventEmitter.call(this);\n\t\n\t  this.options = util.extend({\n\t    serialization: 'binary',\n\t    reliable: false\n\t  }, options);\n\t\n\t  // Connection is not open yet.\n\t  this.open = false;\n\t  this.type = 'data';\n\t  this.peer = peer;\n\t  this.provider = provider;\n\t\n\t  this.id = this.options.connectionId || DataConnection._idPrefix + util.randomToken();\n\t\n\t  this.label = this.options.label || this.id;\n\t  this.metadata = this.options.metadata;\n\t  this.serialization = this.options.serialization;\n\t  this.reliable = this.options.reliable;\n\t\n\t  // Data channel buffering.\n\t  this._buffer = [];\n\t  this._buffering = false;\n\t  this.bufferSize = 0;\n\t\n\t  // For storing large data.\n\t  this._chunkedData = {};\n\t\n\t  if (this.options._payload) {\n\t    this._peerBrowser = this.options._payload.browser;\n\t  }\n\t\n\t  Negotiator.startConnection(\n\t    this,\n\t    this.options._payload || {\n\t      originator: true\n\t    }\n\t  );\n\t}\n\t\n\tutil.inherits(DataConnection, EventEmitter);\n\t\n\tDataConnection._idPrefix = 'dc_';\n\t\n\t/** Called by the Negotiator when the DataChannel is ready. */\n\tDataConnection.prototype.initialize = function(dc) {\n\t  this._dc = this.dataChannel = dc;\n\t  this._configureDataChannel();\n\t}\n\t\n\tDataConnection.prototype._configureDataChannel = function() {\n\t  var self = this;\n\t  if (util.supports.sctp) {\n\t    this._dc.binaryType = 'arraybuffer';\n\t  }\n\t  this._dc.onopen = function() {\n\t    util.log('Data channel connection success');\n\t    self.open = true;\n\t    self.emit('open');\n\t  }\n\t\n\t  // Use the Reliable shim for non Firefox browsers\n\t  if (!util.supports.sctp && this.reliable) {\n\t    this._reliable = new Reliable(this._dc, util.debug);\n\t  }\n\t\n\t  if (this._reliable) {\n\t    this._reliable.onmessage = function(msg) {\n\t      self.emit('data', msg);\n\t    };\n\t  } else {\n\t    this._dc.onmessage = function(e) {\n\t      self._handleDataMessage(e);\n\t    };\n\t  }\n\t  this._dc.onclose = function(e) {\n\t    util.log('DataChannel closed for:', self.peer);\n\t    self.close();\n\t  };\n\t}\n\t\n\t// Handles a DataChannel message.\n\tDataConnection.prototype._handleDataMessage = function(e) {\n\t  var self = this;\n\t  var data = e.data;\n\t  var datatype = data.constructor;\n\t  if (this.serialization === 'binary' || this.serialization === 'binary-utf8') {\n\t    if (datatype === Blob) {\n\t      // Datatype should never be blob\n\t      util.blobToArrayBuffer(data, function(ab) {\n\t        data = util.unpack(ab);\n\t        self.emit('data', data);\n\t      });\n\t      return;\n\t    } else if (datatype === ArrayBuffer) {\n\t      data = util.unpack(data);\n\t    } else if (datatype === String) {\n\t      // String fallback for binary data for browsers that don't support binary yet\n\t      var ab = util.binaryStringToArrayBuffer(data);\n\t      data = util.unpack(ab);\n\t    }\n\t  } else if (this.serialization === 'json') {\n\t    data = JSON.parse(data);\n\t  }\n\t\n\t  // Check if we've chunked--if so, piece things back together.\n\t  // We're guaranteed that this isn't 0.\n\t  if (data.__peerData) {\n\t    var id = data.__peerData;\n\t    var chunkInfo = this._chunkedData[id] || {data: [], count: 0, total: data.total};\n\t\n\t    chunkInfo.data[data.n] = data.data;\n\t    chunkInfo.count += 1;\n\t\n\t    if (chunkInfo.total === chunkInfo.count) {\n\t      // Clean up before making the recursive call to `_handleDataMessage`.\n\t      delete this._chunkedData[id];\n\t\n\t      // We've received all the chunks--time to construct the complete data.\n\t      data = new Blob(chunkInfo.data);\n\t      this._handleDataMessage({data: data});\n\t    }\n\t\n\t    this._chunkedData[id] = chunkInfo;\n\t    return;\n\t  }\n\t\n\t  this.emit('data', data);\n\t}\n\t\n\t/**\n\t * Exposed functionality for users.\n\t */\n\t\n\t/** Allows user to close connection. */\n\tDataConnection.prototype.close = function() {\n\t  if (!this.open) {\n\t    return;\n\t  }\n\t  this.open = false;\n\t  Negotiator.cleanup(this);\n\t  this.emit('close');\n\t}\n\t\n\t/** Allows user to send data. */\n\tDataConnection.prototype.send = function(data, chunked) {\n\t  if (!this.open) {\n\t    this.emit('error', new Error('Connection is not open. You should listen for the `open` event before sending messages.'));\n\t    return;\n\t  }\n\t  if (this._reliable) {\n\t    // Note: reliable shim sending will make it so that you cannot customize\n\t    // serialization.\n\t    this._reliable.send(data);\n\t    return;\n\t  }\n\t  var self = this;\n\t  if (this.serialization === 'json') {\n\t    this._bufferedSend(JSON.stringify(data));\n\t  } else if (this.serialization === 'binary' || this.serialization === 'binary-utf8') {\n\t    var blob = util.pack(data);\n\t\n\t    // For Chrome-Firefox interoperability, we need to make Firefox \"chunk\"\n\t    // the data it sends out.\n\t    var needsChunking = util.chunkedBrowsers[this._peerBrowser] || util.chunkedBrowsers[util.browser];\n\t    if (needsChunking && !chunked && blob.size > util.chunkedMTU) {\n\t      this._sendChunks(blob);\n\t      return;\n\t    }\n\t\n\t    // DataChannel currently only supports strings.\n\t    if (!util.supports.sctp) {\n\t      util.blobToBinaryString(blob, function(str) {\n\t        self._bufferedSend(str);\n\t      });\n\t    } else if (!util.supports.binaryBlob) {\n\t      // We only do this if we really need to (e.g. blobs are not supported),\n\t      // because this conversion is costly.\n\t      util.blobToArrayBuffer(blob, function(ab) {\n\t        self._bufferedSend(ab);\n\t      });\n\t    } else {\n\t      this._bufferedSend(blob);\n\t    }\n\t  } else {\n\t    this._bufferedSend(data);\n\t  }\n\t}\n\t\n\tDataConnection.prototype._bufferedSend = function(msg) {\n\t  if (this._buffering || !this._trySend(msg)) {\n\t    this._buffer.push(msg);\n\t    this.bufferSize = this._buffer.length;\n\t  }\n\t}\n\t\n\t// Returns true if the send succeeds.\n\tDataConnection.prototype._trySend = function(msg) {\n\t  try {\n\t    this._dc.send(msg);\n\t  } catch (e) {\n\t    this._buffering = true;\n\t\n\t    var self = this;\n\t    setTimeout(function() {\n\t      // Try again.\n\t      self._buffering = false;\n\t      self._tryBuffer();\n\t    }, 100);\n\t    return false;\n\t  }\n\t  return true;\n\t}\n\t\n\t// Try to send the first message in the buffer.\n\tDataConnection.prototype._tryBuffer = function() {\n\t  if (this._buffer.length === 0) {\n\t    return;\n\t  }\n\t\n\t  var msg = this._buffer[0];\n\t\n\t  if (this._trySend(msg)) {\n\t    this._buffer.shift();\n\t    this.bufferSize = this._buffer.length;\n\t    this._tryBuffer();\n\t  }\n\t}\n\t\n\tDataConnection.prototype._sendChunks = function(blob) {\n\t  var blobs = util.chunk(blob);\n\t  for (var i = 0, ii = blobs.length; i < ii; i += 1) {\n\t    var blob = blobs[i];\n\t    this.send(blob, true);\n\t  }\n\t}\n\t\n\tDataConnection.prototype.handleMessage = function(message) {\n\t  var payload = message.payload;\n\t\n\t  switch (message.type) {\n\t    case 'ANSWER':\n\t      this._peerBrowser = payload.browser;\n\t\n\t      // Forward to negotiator\n\t      Negotiator.handleSDP(message.type, this, payload.sdp);\n\t      break;\n\t    case 'CANDIDATE':\n\t      Negotiator.handleCandidate(this, payload.candidate);\n\t      break;\n\t    default:\n\t      util.warn('Unrecognized message type:', message.type, 'from peer:', this.peer);\n\t      break;\n\t  }\n\t}\n\t\n\tmodule.exports = DataConnection;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(1);\n\tvar EventEmitter = __webpack_require__(3);\n\tvar Negotiator = __webpack_require__(6);\n\t\n\t/**\n\t * Wraps the streaming interface between two Peers.\n\t */\n\tfunction MediaConnection(peer, provider, options) {\n\t  if (!(this instanceof MediaConnection)) return new MediaConnection(peer, provider, options);\n\t  EventEmitter.call(this);\n\t\n\t  this.options = util.extend({}, options);\n\t\n\t  this.open = false;\n\t  this.type = 'media';\n\t  this.peer = peer;\n\t  this.provider = provider;\n\t  this.metadata = this.options.metadata;\n\t  this.localStream = this.options._stream;\n\t\n\t  this.id = this.options.connectionId || MediaConnection._idPrefix + util.randomToken();\n\t  if (this.localStream) {\n\t    Negotiator.startConnection(\n\t      this,\n\t      {_stream: this.localStream, originator: true}\n\t    );\n\t  }\n\t};\n\t\n\tutil.inherits(MediaConnection, EventEmitter);\n\t\n\tMediaConnection._idPrefix = 'mc_';\n\t\n\tMediaConnection.prototype.addStream = function(remoteStream) {\n\t  util.log('Receiving stream', remoteStream);\n\t\n\t  this.remoteStream = remoteStream;\n\t  this.emit('stream', remoteStream); // Should we call this `open`?\n\t\n\t};\n\t\n\tMediaConnection.prototype.handleMessage = function(message) {\n\t  var payload = message.payload;\n\t\n\t  switch (message.type) {\n\t    case 'ANSWER':\n\t      // Forward to negotiator\n\t      Negotiator.handleSDP(message.type, this, payload.sdp);\n\t      this.open = true;\n\t      break;\n\t    case 'CANDIDATE':\n\t      Negotiator.handleCandidate(this, payload.candidate);\n\t      break;\n\t    default:\n\t      util.warn('Unrecognized message type:', message.type, 'from peer:', this.peer);\n\t      break;\n\t  }\n\t}\n\t\n\tMediaConnection.prototype.answer = function(stream) {\n\t  if (this.localStream) {\n\t    util.warn('Local stream already exists on this MediaConnection. Are you answering a call twice?');\n\t    return;\n\t  }\n\t\n\t  this.options._payload._stream = stream;\n\t\n\t  this.localStream = stream;\n\t  Negotiator.startConnection(\n\t    this,\n\t    this.options._payload\n\t  )\n\t  // Retrieve lost messages stored because PeerConnection not set up.\n\t  var messages = this.provider._getMessages(this.id);\n\t  for (var i = 0, ii = messages.length; i < ii; i += 1) {\n\t    this.handleMessage(messages[i]);\n\t  }\n\t  this.open = true;\n\t};\n\t\n\t/**\n\t * Exposed functionality for users.\n\t */\n\t\n\t/** Allows user to close connection. */\n\tMediaConnection.prototype.close = function() {\n\t  if (!this.open) {\n\t    return;\n\t  }\n\t  this.open = false;\n\t  Negotiator.cleanup(this);\n\t  this.emit('close')\n\t};\n\t\n\tmodule.exports = MediaConnection;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(1);\n\tvar EventEmitter = __webpack_require__(3);\n\tvar Socket = __webpack_require__(12);\n\tvar MediaConnection = __webpack_require__(10);\n\tvar DataConnection = __webpack_require__(9);\n\t\n\t/**\n\t * A peer who can initiate connections with other peers.\n\t */\n\tfunction Peer(id, options) {\n\t  if (!(this instanceof Peer)) return new Peer(id, options);\n\t  EventEmitter.call(this);\n\t\n\t  // Deal with overloading\n\t  if (id && id.constructor == Object) {\n\t    options = id;\n\t    id = undefined;\n\t  } else if (id) {\n\t    // Ensure id is a string\n\t    id = id.toString();\n\t  }\n\t  //\n\t\n\t  // Configurize options\n\t  options = util.extend({\n\t    debug: 0, // 1: Errors, 2: Warnings, 3: All logs\n\t    host: util.CLOUD_HOST,\n\t    port: util.CLOUD_PORT,\n\t    key: 'peerjs',\n\t    path: '/',\n\t    token: util.randomToken(),\n\t    config: util.defaultConfig\n\t  }, options);\n\t  this.options = options;\n\t  // Detect relative URL host.\n\t  if (options.host === '/') {\n\t    options.host = window.location.hostname;\n\t  }\n\t  // Set path correctly.\n\t  if (options.path[0] !== '/') {\n\t    options.path = '/' + options.path;\n\t  }\n\t  if (options.path[options.path.length - 1] !== '/') {\n\t    options.path += '/';\n\t  }\n\t\n\t  // Set whether we use SSL to same as current host\n\t  if (options.secure === undefined && options.host !== util.CLOUD_HOST) {\n\t    options.secure = util.isSecure();\n\t  }\n\t  // Set a custom log function if present\n\t  if (options.logFunction) {\n\t    util.setLogFunction(options.logFunction);\n\t  }\n\t  util.setLogLevel(options.debug);\n\t  //\n\t\n\t  // Sanity checks\n\t  // Ensure WebRTC supported\n\t  if (!util.supports.audioVideo && !util.supports.data ) {\n\t    this._delayedAbort('browser-incompatible', 'The current browser does not support WebRTC');\n\t    return;\n\t  }\n\t  // Ensure alphanumeric id\n\t  if (!util.validateId(id)) {\n\t    this._delayedAbort('invalid-id', 'ID \"' + id + '\" is invalid');\n\t    return;\n\t  }\n\t  // Ensure valid key\n\t  if (!util.validateKey(options.key)) {\n\t    this._delayedAbort('invalid-key', 'API KEY \"' + options.key + '\" is invalid');\n\t    return;\n\t  }\n\t  // Ensure not using unsecure cloud server on SSL page\n\t  if (options.secure && options.host === '0.peerjs.com') {\n\t    this._delayedAbort('ssl-unavailable',\n\t      'The cloud server currently does not support HTTPS. Please run your own PeerServer to use HTTPS.');\n\t    return;\n\t  }\n\t  //\n\t\n\t  // States.\n\t  this.destroyed = false; // Connections have been killed\n\t  this.disconnected = false; // Connection to PeerServer killed but P2P connections still active\n\t  this.open = false; // Sockets and such are not yet open.\n\t  //\n\t\n\t  // References\n\t  this.connections = {}; // DataConnections for this peer.\n\t  this._lostMessages = {}; // src => [list of messages]\n\t  //\n\t\n\t  // Start the server connection\n\t  this._initializeServerConnection();\n\t  if (id) {\n\t    this._initialize(id);\n\t  } else {\n\t    this._retrieveId();\n\t  }\n\t  //\n\t}\n\t\n\tutil.inherits(Peer, EventEmitter);\n\t\n\t// Initialize the 'socket' (which is actually a mix of XHR streaming and\n\t// websockets.)\n\tPeer.prototype._initializeServerConnection = function() {\n\t  var self = this;\n\t  this.socket = new Socket(this.options.secure, this.options.host, this.options.port, this.options.path, this.options.key);\n\t  this.socket.on('message', function(data) {\n\t    self._handleMessage(data);\n\t  });\n\t  this.socket.on('error', function(error) {\n\t    self._abort('socket-error', error);\n\t  });\n\t  this.socket.on('disconnected', function() {\n\t    // If we haven't explicitly disconnected, emit error and disconnect.\n\t    if (!self.disconnected) {\n\t      self.emitError('network', 'Lost connection to server.');\n\t      self.disconnect();\n\t    }\n\t  });\n\t  this.socket.on('close', function() {\n\t    // If we haven't explicitly disconnected, emit error.\n\t    if (!self.disconnected) {\n\t      self._abort('socket-closed', 'Underlying socket is already closed.');\n\t    }\n\t  });\n\t};\n\t\n\t/** Get a unique ID from the server via XHR. */\n\tPeer.prototype._retrieveId = function(cb) {\n\t  var self = this;\n\t  var http = new XMLHttpRequest();\n\t  var protocol = this.options.secure ? 'https://' : 'http://';\n\t  var url = protocol + this.options.host + ':' + this.options.port +\n\t    this.options.path + this.options.key + '/id';\n\t  var queryString = '?ts=' + new Date().getTime() + '' + Math.random();\n\t  url += queryString;\n\t\n\t  // If there's no ID we need to wait for one before trying to init socket.\n\t  http.open('get', url, true);\n\t  http.onerror = function(e) {\n\t    util.error('Error retrieving ID', e);\n\t    var pathError = '';\n\t    if (self.options.path === '/' && self.options.host !== util.CLOUD_HOST) {\n\t      pathError = ' If you passed in a `path` to your self-hosted PeerServer, ' +\n\t        'you\\'ll also need to pass in that same path when creating a new ' +\n\t        'Peer.';\n\t    }\n\t    self._abort('server-error', 'Could not get an ID from the server.' + pathError);\n\t  };\n\t  http.onreadystatechange = function() {\n\t    if (http.readyState !== 4) {\n\t      return;\n\t    }\n\t    if (http.status !== 200) {\n\t      http.onerror();\n\t      return;\n\t    }\n\t    self._initialize(http.responseText);\n\t  };\n\t  http.send(null);\n\t};\n\t\n\t/** Initialize a connection with the server. */\n\tPeer.prototype._initialize = function(id) {\n\t  this.id = id;\n\t  this.socket.start(this.id, this.options.token);\n\t};\n\t\n\t/** Handles messages from the server. */\n\tPeer.prototype._handleMessage = function(message) {\n\t  var type = message.type;\n\t  var payload = message.payload;\n\t  var peer = message.src;\n\t  var connection;\n\t\n\t  switch (type) {\n\t    case 'OPEN': // The connection to the server is open.\n\t      this.emit('open', this.id);\n\t      this.open = true;\n\t      break;\n\t    case 'ERROR': // Server error.\n\t      this._abort('server-error', payload.msg);\n\t      break;\n\t    case 'ID-TAKEN': // The selected ID is taken.\n\t      this._abort('unavailable-id', 'ID `' + this.id + '` is taken');\n\t      break;\n\t    case 'INVALID-KEY': // The given API key cannot be found.\n\t      this._abort('invalid-key', 'API KEY \"' + this.options.key + '\" is invalid');\n\t      break;\n\t\n\t    //\n\t    case 'LEAVE': // Another peer has closed its connection to this peer.\n\t      util.log('Received leave message from', peer);\n\t      this._cleanupPeer(peer);\n\t      break;\n\t\n\t    case 'EXPIRE': // The offer sent to a peer has expired without response.\n\t      this.emitError('peer-unavailable', 'Could not connect to peer ' + peer);\n\t      break;\n\t    case 'OFFER': // we should consider switching this to CALL/CONNECT, but this is the least breaking option.\n\t      var connectionId = payload.connectionId;\n\t      connection = this.getConnection(peer, connectionId);\n\t\n\t      if (connection) {\n\t        util.warn('Offer received for existing Connection ID:', connectionId);\n\t        //connection.handleMessage(message);\n\t      } else {\n\t        // Create a new connection.\n\t        if (payload.type === 'media') {\n\t          connection = new MediaConnection(peer, this, {\n\t            connectionId: connectionId,\n\t            _payload: payload,\n\t            metadata: payload.metadata\n\t          });\n\t          this._addConnection(peer, connection);\n\t          this.emit('call', connection);\n\t        } else if (payload.type === 'data') {\n\t          connection = new DataConnection(peer, this, {\n\t            connectionId: connectionId,\n\t            _payload: payload,\n\t            metadata: payload.metadata,\n\t            label: payload.label,\n\t            serialization: payload.serialization,\n\t            reliable: payload.reliable\n\t          });\n\t          this._addConnection(peer, connection);\n\t          this.emit('connection', connection);\n\t        } else {\n\t          util.warn('Received malformed connection type:', payload.type);\n\t          return;\n\t        }\n\t        // Find messages.\n\t        var messages = this._getMessages(connectionId);\n\t        for (var i = 0, ii = messages.length; i < ii; i += 1) {\n\t          connection.handleMessage(messages[i]);\n\t        }\n\t      }\n\t      break;\n\t    default:\n\t      if (!payload) {\n\t        util.warn('You received a malformed message from ' + peer + ' of type ' + type);\n\t        return;\n\t      }\n\t\n\t      var id = payload.connectionId;\n\t      connection = this.getConnection(peer, id);\n\t\n\t      if (connection && connection.pc) {\n\t        // Pass it on.\n\t        connection.handleMessage(message);\n\t      } else if (id) {\n\t        // Store for possible later use\n\t        this._storeMessage(id, message);\n\t      } else {\n\t        util.warn('You received an unrecognized message:', message);\n\t      }\n\t      break;\n\t  }\n\t};\n\t\n\t/** Stores messages without a set up connection, to be claimed later. */\n\tPeer.prototype._storeMessage = function(connectionId, message) {\n\t  if (!this._lostMessages[connectionId]) {\n\t    this._lostMessages[connectionId] = [];\n\t  }\n\t  this._lostMessages[connectionId].push(message);\n\t};\n\t\n\t/** Retrieve messages from lost message store */\n\tPeer.prototype._getMessages = function(connectionId) {\n\t  var messages = this._lostMessages[connectionId];\n\t  if (messages) {\n\t    delete this._lostMessages[connectionId];\n\t    return messages;\n\t  } else {\n\t    return [];\n\t  }\n\t};\n\t\n\t/**\n\t * Returns a DataConnection to the specified peer. See documentation for a\n\t * complete list of options.\n\t */\n\tPeer.prototype.connect = function(peer, options) {\n\t  if (this.disconnected) {\n\t    util.warn('You cannot connect to a new Peer because you called ' +\n\t      '.disconnect() on this Peer and ended your connection with the ' +\n\t      'server. You can create a new Peer to reconnect, or call reconnect ' +\n\t      'on this peer if you believe its ID to still be available.');\n\t    this.emitError('disconnected', 'Cannot connect to new Peer after disconnecting from server.');\n\t    return;\n\t  }\n\t  var connection = new DataConnection(peer, this, options);\n\t  this._addConnection(peer, connection);\n\t  return connection;\n\t};\n\t\n\t/**\n\t * Returns a MediaConnection to the specified peer. See documentation for a\n\t * complete list of options.\n\t */\n\tPeer.prototype.call = function(peer, stream, options) {\n\t  if (this.disconnected) {\n\t    util.warn('You cannot connect to a new Peer because you called ' +\n\t      '.disconnect() on this Peer and ended your connection with the ' +\n\t      'server. You can create a new Peer to reconnect.');\n\t    this.emitError('disconnected', 'Cannot connect to new Peer after disconnecting from server.');\n\t    return;\n\t  }\n\t  if (!stream) {\n\t    util.error('To call a peer, you must provide a stream from your browser\\'s `getUserMedia`.');\n\t    return;\n\t  }\n\t  options = options || {};\n\t  options._stream = stream;\n\t  var call = new MediaConnection(peer, this, options);\n\t  this._addConnection(peer, call);\n\t  return call;\n\t};\n\t\n\t/** Add a data/media connection to this peer. */\n\tPeer.prototype._addConnection = function(peer, connection) {\n\t  if (!this.connections[peer]) {\n\t    this.connections[peer] = [];\n\t  }\n\t  this.connections[peer].push(connection);\n\t};\n\t\n\t/** Retrieve a data/media connection for this peer. */\n\tPeer.prototype.getConnection = function(peer, id) {\n\t  var connections = this.connections[peer];\n\t  if (!connections) {\n\t    return null;\n\t  }\n\t  for (var i = 0, ii = connections.length; i < ii; i++) {\n\t    if (connections[i].id === id) {\n\t      return connections[i];\n\t    }\n\t  }\n\t  return null;\n\t};\n\t\n\tPeer.prototype._delayedAbort = function(type, message) {\n\t  var self = this;\n\t  util.setZeroTimeout(function(){\n\t    self._abort(type, message);\n\t  });\n\t};\n\t\n\t/**\n\t * Destroys the Peer and emits an error message.\n\t * The Peer is not destroyed if it's in a disconnected state, in which case\n\t * it retains its disconnected state and its existing connections.\n\t */\n\tPeer.prototype._abort = function(type, message) {\n\t  util.error('Aborting!');\n\t  if (!this._lastServerId) {\n\t    this.destroy();\n\t  } else {\n\t    this.disconnect();\n\t  }\n\t  this.emitError(type, message);\n\t};\n\t\n\t/** Emits a typed error message. */\n\tPeer.prototype.emitError = function(type, err) {\n\t  util.error('Error:', err);\n\t  if (typeof err === 'string') {\n\t    err = new Error(err);\n\t  }\n\t  err.type = type;\n\t  this.emit('error', err);\n\t};\n\t\n\t/**\n\t * Destroys the Peer: closes all active connections as well as the connection\n\t *  to the server.\n\t * Warning: The peer can no longer create or accept connections after being\n\t *  destroyed.\n\t */\n\tPeer.prototype.destroy = function() {\n\t  if (!this.destroyed) {\n\t    this._cleanup();\n\t    this.disconnect();\n\t    this.destroyed = true;\n\t  }\n\t};\n\t\n\t\n\t/** Disconnects every connection on this peer. */\n\tPeer.prototype._cleanup = function() {\n\t  if (this.connections) {\n\t    var peers = Object.keys(this.connections);\n\t    for (var i = 0, ii = peers.length; i < ii; i++) {\n\t      this._cleanupPeer(peers[i]);\n\t    }\n\t  }\n\t  this.emit('close');\n\t};\n\t\n\t/** Closes all connections to this peer. */\n\tPeer.prototype._cleanupPeer = function(peer) {\n\t  var connections = this.connections[peer];\n\t  for (var j = 0, jj = connections.length; j < jj; j += 1) {\n\t    connections[j].close();\n\t  }\n\t};\n\t\n\t/**\n\t * Disconnects the Peer's connection to the PeerServer. Does not close any\n\t *  active connections.\n\t * Warning: The peer can no longer create or accept connections after being\n\t *  disconnected. It also cannot reconnect to the server.\n\t */\n\tPeer.prototype.disconnect = function() {\n\t  var self = this;\n\t  util.setZeroTimeout(function(){\n\t    if (!self.disconnected) {\n\t      self.disconnected = true;\n\t      self.open = false;\n\t      if (self.socket) {\n\t        self.socket.close();\n\t      }\n\t      self.emit('disconnected', self.id);\n\t      self._lastServerId = self.id;\n\t      self.id = null;\n\t    }\n\t  });\n\t};\n\t\n\t/** Attempts to reconnect with the same ID. */\n\tPeer.prototype.reconnect = function() {\n\t  if (this.disconnected && !this.destroyed) {\n\t    util.log('Attempting reconnection to server with ID ' + this._lastServerId);\n\t    this.disconnected = false;\n\t    this._initializeServerConnection();\n\t    this._initialize(this._lastServerId);\n\t  } else if (this.destroyed) {\n\t    throw new Error('This peer cannot reconnect to the server. It has already been destroyed.');\n\t  } else if (!this.disconnected && !this.open) {\n\t    // Do nothing. We're still connecting the first time.\n\t    util.error('In a hurry? We\\'re still trying to make the initial connection!');\n\t  } else {\n\t    throw new Error('Peer ' + this.id + ' cannot reconnect because it is not disconnected from the server!');\n\t  }\n\t};\n\t\n\t/**\n\t * Get a list of available peer IDs. If you're running your own server, you'll\n\t * want to set allow_discovery: true in the PeerServer options. If you're using\n\t * the cloud server, email team@peerjs.com to get the functionality enabled for\n\t * your key.\n\t */\n\tPeer.prototype.listAllPeers = function(cb) {\n\t  cb = cb || function() {};\n\t  var self = this;\n\t  var http = new XMLHttpRequest();\n\t  var protocol = this.options.secure ? 'https://' : 'http://';\n\t  var url = protocol + this.options.host + ':' + this.options.port +\n\t    this.options.path + this.options.key + '/peers';\n\t  var queryString = '?ts=' + new Date().getTime() + '' + Math.random();\n\t  url += queryString;\n\t\n\t  // If there's no ID we need to wait for one before trying to init socket.\n\t  http.open('get', url, true);\n\t  http.onerror = function(e) {\n\t    self._abort('server-error', 'Could not get peers from the server.');\n\t    cb([]);\n\t  };\n\t  http.onreadystatechange = function() {\n\t    if (http.readyState !== 4) {\n\t      return;\n\t    }\n\t    if (http.status === 401) {\n\t      var helpfulError = '';\n\t      if (self.options.host !== util.CLOUD_HOST) {\n\t        helpfulError = 'It looks like you\\'re using the cloud server. You can email ' +\n\t          'team@peerjs.com to enable peer listing for your API key.';\n\t      } else {\n\t        helpfulError = 'You need to enable `allow_discovery` on your self-hosted ' +\n\t          'PeerServer to use this feature.';\n\t      }\n\t      cb([]);\n\t      throw new Error('It doesn\\'t look like you have permission to list peers IDs. ' + helpfulError);\n\t    } else if (http.status !== 200) {\n\t      cb([]);\n\t    } else {\n\t      cb(JSON.parse(http.responseText));\n\t    }\n\t  };\n\t  http.send(null);\n\t};\n\t\n\tmodule.exports = Peer;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(1);\n\tvar EventEmitter = __webpack_require__(3);\n\t\n\t/**\n\t * An abstraction on top of WebSockets and XHR streaming to provide fastest\n\t * possible connection for peers.\n\t */\n\tfunction Socket(secure, host, port, path, key) {\n\t  if (!(this instanceof Socket)) return new Socket(secure, host, port, path, key);\n\t\n\t  EventEmitter.call(this);\n\t\n\t  // Disconnected manually.\n\t  this.disconnected = false;\n\t  this._queue = [];\n\t\n\t  var httpProtocol = secure ? 'https://' : 'http://';\n\t  var wsProtocol = secure ? 'wss://' : 'ws://';\n\t  this._httpUrl = httpProtocol + host + ':' + port + path + key;\n\t  this._wsUrl = wsProtocol + host + ':' + port + path + 'peerjs?key=' + key;\n\t}\n\t\n\tutil.inherits(Socket, EventEmitter);\n\t\n\t\n\t/** Check in with ID or get one from server. */\n\tSocket.prototype.start = function(id, token) {\n\t  this.id = id;\n\t\n\t  this._httpUrl += '/' + id + '/' + token;\n\t  this._wsUrl += '&id=' + id + '&token=' + token;\n\t\n\t  this._startXhrStream();\n\t  this._startWebSocket();\n\t}\n\t\n\t\n\t/** Start up websocket communications. */\n\tSocket.prototype._startWebSocket = function(id) {\n\t  var self = this;\n\t\n\t  if (this._socket) {\n\t    return;\n\t  }\n\t\n\t  this._socket = new WebSocket(this._wsUrl);\n\t\n\t  this._socket.onmessage = function(event) {\n\t    try {\n\t      var data = JSON.parse(event.data);\n\t    } catch(e) {\n\t      util.log('Invalid server message', event.data);\n\t      return;\n\t    }\n\t    self.emit('message', data);\n\t  };\n\t\n\t  this._socket.onclose = function(event) {\n\t    util.log('Socket closed.');\n\t    self.disconnected = true;\n\t    self.emit('disconnected');\n\t  };\n\t\n\t  // Take care of the queue of connections if necessary and make sure Peer knows\n\t  // socket is open.\n\t  this._socket.onopen = function() {\n\t    if (self._timeout) {\n\t      clearTimeout(self._timeout);\n\t      setTimeout(function(){\n\t        self._http.abort();\n\t        self._http = null;\n\t      }, 5000);\n\t    }\n\t    self._sendQueuedMessages();\n\t    util.log('Socket open');\n\t  };\n\t}\n\t\n\t/** Start XHR streaming. */\n\tSocket.prototype._startXhrStream = function(n) {\n\t  try {\n\t    var self = this;\n\t    this._http = new XMLHttpRequest();\n\t    this._http._index = 1;\n\t    this._http._streamIndex = n || 0;\n\t    this._http.open('post', this._httpUrl + '/id?i=' + this._http._streamIndex, true);\n\t    this._http.onerror = function() {\n\t      // If we get an error, likely something went wrong.\n\t      // Stop streaming.\n\t      clearTimeout(self._timeout);\n\t      self.emit('disconnected');\n\t    }\n\t    this._http.onreadystatechange = function() {\n\t      if (this.readyState == 2 && this.old) {\n\t        this.old.abort();\n\t        delete this.old;\n\t      } else if (this.readyState > 2 && this.status === 200 && this.responseText) {\n\t        self._handleStream(this);\n\t      }\n\t    };\n\t    this._http.send(null);\n\t    this._setHTTPTimeout();\n\t  } catch(e) {\n\t    util.log('XMLHttpRequest not available; defaulting to WebSockets');\n\t  }\n\t}\n\t\n\t\n\t/** Handles onreadystatechange response as a stream. */\n\tSocket.prototype._handleStream = function(http) {\n\t  // 3 and 4 are loading/done state. All others are not relevant.\n\t  var messages = http.responseText.split('\\n');\n\t\n\t  // Check to see if anything needs to be processed on buffer.\n\t  if (http._buffer) {\n\t    while (http._buffer.length > 0) {\n\t      var index = http._buffer.shift();\n\t      var bufferedMessage = messages[index];\n\t      try {\n\t        bufferedMessage = JSON.parse(bufferedMessage);\n\t      } catch(e) {\n\t        http._buffer.shift(index);\n\t        break;\n\t      }\n\t      this.emit('message', bufferedMessage);\n\t    }\n\t  }\n\t\n\t  var message = messages[http._index];\n\t  if (message) {\n\t    http._index += 1;\n\t    // Buffering--this message is incomplete and we'll get to it next time.\n\t    // This checks if the httpResponse ended in a `\\n`, in which case the last\n\t    // element of messages should be the empty string.\n\t    if (http._index === messages.length) {\n\t      if (!http._buffer) {\n\t        http._buffer = [];\n\t      }\n\t      http._buffer.push(http._index - 1);\n\t    } else {\n\t      try {\n\t        message = JSON.parse(message);\n\t      } catch(e) {\n\t        util.log('Invalid server message', message);\n\t        return;\n\t      }\n\t      this.emit('message', message);\n\t    }\n\t  }\n\t}\n\t\n\tSocket.prototype._setHTTPTimeout = function() {\n\t  var self = this;\n\t  this._timeout = setTimeout(function() {\n\t    var old = self._http;\n\t    if (!self._wsOpen()) {\n\t      self._startXhrStream(old._streamIndex + 1);\n\t      self._http.old = old;\n\t    } else {\n\t      old.abort();\n\t    }\n\t  }, 25000);\n\t}\n\t\n\t/** Is the websocket currently open? */\n\tSocket.prototype._wsOpen = function() {\n\t  return this._socket && this._socket.readyState == 1;\n\t}\n\t\n\t/** Send queued messages. */\n\tSocket.prototype._sendQueuedMessages = function() {\n\t  for (var i = 0, ii = this._queue.length; i < ii; i += 1) {\n\t    this.send(this._queue[i]);\n\t  }\n\t}\n\t\n\t/** Exposed send for DC & Peer. */\n\tSocket.prototype.send = function(data) {\n\t  if (this.disconnected) {\n\t    return;\n\t  }\n\t\n\t  // If we didn't get an ID yet, we can't yet send anything so we should queue\n\t  // up these messages.\n\t  if (!this.id) {\n\t    this._queue.push(data);\n\t    return;\n\t  }\n\t\n\t  if (!data.type) {\n\t    this.emit('error', 'Invalid message');\n\t    return;\n\t  }\n\t\n\t  var message = JSON.stringify(data);\n\t  if (this._wsOpen()) {\n\t    this._socket.send(message);\n\t  } else {\n\t    var http = new XMLHttpRequest();\n\t    var url = this._httpUrl + '/' + data.type.toLowerCase();\n\t    http.open('post', url, true);\n\t    http.setRequestHeader('Content-Type', 'application/json');\n\t    http.send(message);\n\t  }\n\t}\n\t\n\tSocket.prototype.close = function() {\n\t  if (!this.disconnected && this._wsOpen()) {\n\t    this._socket.close();\n\t    this.disconnected = true;\n\t  }\n\t}\n\t\n\tmodule.exports = Socket;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(14);\n\t\n\t/**\n\t * Reliable transfer for Chrome Canary DataChannel impl.\n\t * Author: @michellebu\n\t */\n\tfunction Reliable(dc, debug) {\n\t  if (!(this instanceof Reliable)) return new Reliable(dc);\n\t  this._dc = dc;\n\t\n\t  util.debug = debug;\n\t\n\t  // Messages sent/received so far.\n\t  // id: { ack: n, chunks: [...] }\n\t  this._outgoing = {};\n\t  // id: { ack: ['ack', id, n], chunks: [...] }\n\t  this._incoming = {};\n\t  this._received = {};\n\t\n\t  // Window size.\n\t  this._window = 1000;\n\t  // MTU.\n\t  this._mtu = 500;\n\t  // Interval for setInterval. In ms.\n\t  this._interval = 0;\n\t\n\t  // Messages sent.\n\t  this._count = 0;\n\t\n\t  // Outgoing message queue.\n\t  this._queue = [];\n\t\n\t  this._setupDC();\n\t};\n\t\n\t// Send a message reliably.\n\tReliable.prototype.send = function(msg) {\n\t  // Determine if chunking is necessary.\n\t  var bl = util.pack(msg);\n\t  if (bl.size < this._mtu) {\n\t    this._handleSend(['no', bl]);\n\t    return;\n\t  }\n\t\n\t  this._outgoing[this._count] = {\n\t    ack: 0,\n\t    chunks: this._chunk(bl)\n\t  };\n\t\n\t  if (util.debug) {\n\t    this._outgoing[this._count].timer = new Date();\n\t  }\n\t\n\t  // Send prelim window.\n\t  this._sendWindowedChunks(this._count);\n\t  this._count += 1;\n\t};\n\t\n\t// Set up interval for processing queue.\n\tReliable.prototype._setupInterval = function() {\n\t  // TODO: fail gracefully.\n\t\n\t  var self = this;\n\t  this._timeout = setInterval(function() {\n\t    // FIXME: String stuff makes things terribly async.\n\t    var msg = self._queue.shift();\n\t    if (msg._multiple) {\n\t      for (var i = 0, ii = msg.length; i < ii; i += 1) {\n\t        self._intervalSend(msg[i]);\n\t      }\n\t    } else {\n\t      self._intervalSend(msg);\n\t    }\n\t  }, this._interval);\n\t};\n\t\n\tReliable.prototype._intervalSend = function(msg) {\n\t  var self = this;\n\t  msg = util.pack(msg);\n\t  util.blobToBinaryString(msg, function(str) {\n\t    self._dc.send(str);\n\t  });\n\t  if (self._queue.length === 0) {\n\t    clearTimeout(self._timeout);\n\t    self._timeout = null;\n\t    //self._processAcks();\n\t  }\n\t};\n\t\n\t// Go through ACKs to send missing pieces.\n\tReliable.prototype._processAcks = function() {\n\t  for (var id in this._outgoing) {\n\t    if (this._outgoing.hasOwnProperty(id)) {\n\t      this._sendWindowedChunks(id);\n\t    }\n\t  }\n\t};\n\t\n\t// Handle sending a message.\n\t// FIXME: Don't wait for interval time for all messages...\n\tReliable.prototype._handleSend = function(msg) {\n\t  var push = true;\n\t  for (var i = 0, ii = this._queue.length; i < ii; i += 1) {\n\t    var item = this._queue[i];\n\t    if (item === msg) {\n\t      push = false;\n\t    } else if (item._multiple && item.indexOf(msg) !== -1) {\n\t      push = false;\n\t    }\n\t  }\n\t  if (push) {\n\t    this._queue.push(msg);\n\t    if (!this._timeout) {\n\t      this._setupInterval();\n\t    }\n\t  }\n\t};\n\t\n\t// Set up DataChannel handlers.\n\tReliable.prototype._setupDC = function() {\n\t  // Handle various message types.\n\t  var self = this;\n\t  this._dc.onmessage = function(e) {\n\t    var msg = e.data;\n\t    var datatype = msg.constructor;\n\t    // FIXME: msg is String until binary is supported.\n\t    // Once that happens, this will have to be smarter.\n\t    if (datatype === String) {\n\t      var ab = util.binaryStringToArrayBuffer(msg);\n\t      msg = util.unpack(ab);\n\t      self._handleMessage(msg);\n\t    }\n\t  };\n\t};\n\t\n\t// Handles an incoming message.\n\tReliable.prototype._handleMessage = function(msg) {\n\t  var id = msg[1];\n\t  var idata = this._incoming[id];\n\t  var odata = this._outgoing[id];\n\t  var data;\n\t  switch (msg[0]) {\n\t    // No chunking was done.\n\t    case 'no':\n\t      var message = id;\n\t      if (!!message) {\n\t        this.onmessage(util.unpack(message));\n\t      }\n\t      break;\n\t    // Reached the end of the message.\n\t    case 'end':\n\t      data = idata;\n\t\n\t      // In case end comes first.\n\t      this._received[id] = msg[2];\n\t\n\t      if (!data) {\n\t        break;\n\t      }\n\t\n\t      this._ack(id);\n\t      break;\n\t    case 'ack':\n\t      data = odata;\n\t      if (!!data) {\n\t        var ack = msg[2];\n\t        // Take the larger ACK, for out of order messages.\n\t        data.ack = Math.max(ack, data.ack);\n\t\n\t        // Clean up when all chunks are ACKed.\n\t        if (data.ack >= data.chunks.length) {\n\t          util.log('Time: ', new Date() - data.timer);\n\t          delete this._outgoing[id];\n\t        } else {\n\t          this._processAcks();\n\t        }\n\t      }\n\t      // If !data, just ignore.\n\t      break;\n\t    // Received a chunk of data.\n\t    case 'chunk':\n\t      // Create a new entry if none exists.\n\t      data = idata;\n\t      if (!data) {\n\t        var end = this._received[id];\n\t        if (end === true) {\n\t          break;\n\t        }\n\t        data = {\n\t          ack: ['ack', id, 0],\n\t          chunks: []\n\t        };\n\t        this._incoming[id] = data;\n\t      }\n\t\n\t      var n = msg[2];\n\t      var chunk = msg[3];\n\t      data.chunks[n] = new Uint8Array(chunk);\n\t\n\t      // If we get the chunk we're looking for, ACK for next missing.\n\t      // Otherwise, ACK the same N again.\n\t      if (n === data.ack[2]) {\n\t        this._calculateNextAck(id);\n\t      }\n\t      this._ack(id);\n\t      break;\n\t    default:\n\t      // Shouldn't happen, but would make sense for message to just go\n\t      // through as is.\n\t      this._handleSend(msg);\n\t      break;\n\t  }\n\t};\n\t\n\t// Chunks BL into smaller messages.\n\tReliable.prototype._chunk = function(bl) {\n\t  var chunks = [];\n\t  var size = bl.size;\n\t  var start = 0;\n\t  while (start < size) {\n\t    var end = Math.min(size, start + this._mtu);\n\t    var b = bl.slice(start, end);\n\t    var chunk = {\n\t      payload: b\n\t    }\n\t    chunks.push(chunk);\n\t    start = end;\n\t  }\n\t  util.log('Created', chunks.length, 'chunks.');\n\t  return chunks;\n\t};\n\t\n\t// Sends ACK N, expecting Nth blob chunk for message ID.\n\tReliable.prototype._ack = function(id) {\n\t  var ack = this._incoming[id].ack;\n\t\n\t  // if ack is the end value, then call _complete.\n\t  if (this._received[id] === ack[2]) {\n\t    this._complete(id);\n\t    this._received[id] = true;\n\t  }\n\t\n\t  this._handleSend(ack);\n\t};\n\t\n\t// Calculates the next ACK number, given chunks.\n\tReliable.prototype._calculateNextAck = function(id) {\n\t  var data = this._incoming[id];\n\t  var chunks = data.chunks;\n\t  for (var i = 0, ii = chunks.length; i < ii; i += 1) {\n\t    // This chunk is missing!!! Better ACK for it.\n\t    if (chunks[i] === undefined) {\n\t      data.ack[2] = i;\n\t      return;\n\t    }\n\t  }\n\t  data.ack[2] = chunks.length;\n\t};\n\t\n\t// Sends the next window of chunks.\n\tReliable.prototype._sendWindowedChunks = function(id) {\n\t  util.log('sendWindowedChunks for: ', id);\n\t  var data = this._outgoing[id];\n\t  var ch = data.chunks;\n\t  var chunks = [];\n\t  var limit = Math.min(data.ack + this._window, ch.length);\n\t  for (var i = data.ack; i < limit; i += 1) {\n\t    if (!ch[i].sent || i === data.ack) {\n\t      ch[i].sent = true;\n\t      chunks.push(['chunk', id, i, ch[i].payload]);\n\t    }\n\t  }\n\t  if (data.ack + this._window >= ch.length) {\n\t    chunks.push(['end', id, ch.length])\n\t  }\n\t  chunks._multiple = true;\n\t  this._handleSend(chunks);\n\t};\n\t\n\t// Puts together a message from chunks.\n\tReliable.prototype._complete = function(id) {\n\t  util.log('Completed called for', id);\n\t  var self = this;\n\t  var chunks = this._incoming[id].chunks;\n\t  var bl = new Blob(chunks);\n\t  util.blobToArrayBuffer(bl, function(ab) {\n\t    self.onmessage(util.unpack(ab));\n\t  });\n\t  delete this._incoming[id];\n\t};\n\t\n\t// Ups bandwidth limit on SDP. Meant to be called during offer/answer.\n\tReliable.higherBandwidthSDP = function(sdp) {\n\t  // AS stands for Application-Specific Maximum.\n\t  // Bandwidth number is in kilobits / sec.\n\t  // See RFC for more info: http://www.ietf.org/rfc/rfc2327.txt\n\t\n\t  // Chrome 31+ doesn't want us munging the SDP, so we'll let them have their\n\t  // way.\n\t  var version = navigator.appVersion.match(/Chrome\\/(.*?) /);\n\t  if (version) {\n\t    version = parseInt(version[1].split('.').shift());\n\t    if (version < 31) {\n\t      var parts = sdp.split('b=AS:30');\n\t      var replace = 'b=AS:102400'; // 100 Mbps\n\t      if (parts.length > 1) {\n\t        return parts[0] + replace + parts[1];\n\t      }\n\t    }\n\t  }\n\t\n\t  return sdp;\n\t};\n\t\n\t// Overwritten, typically.\n\tReliable.prototype.onmessage = function(msg) {};\n\t\n\tmodule.exports.Reliable = Reliable;\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar BinaryPack = __webpack_require__(4);\n\t\n\tvar util = {\n\t  debug: false,\n\t  \n\t  inherits: function(ctor, superCtor) {\n\t    ctor.super_ = superCtor;\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  },\n\t  extend: function(dest, source) {\n\t    for(var key in source) {\n\t      if(source.hasOwnProperty(key)) {\n\t        dest[key] = source[key];\n\t      }\n\t    }\n\t    return dest;\n\t  },\n\t  pack: BinaryPack.pack,\n\t  unpack: BinaryPack.unpack,\n\t  \n\t  log: function () {\n\t    if (util.debug) {\n\t      var copy = [];\n\t      for (var i = 0; i < arguments.length; i++) {\n\t        copy[i] = arguments[i];\n\t      }\n\t      copy.unshift('Reliable: ');\n\t      console.log.apply(console, copy);\n\t    }\n\t  },\n\t\n\t  setZeroTimeout: (function(global) {\n\t    var timeouts = [];\n\t    var messageName = 'zero-timeout-message';\n\t\n\t    // Like setTimeout, but only takes a function argument.\t There's\n\t    // no time argument (always zero) and no arguments (you have to\n\t    // use a closure).\n\t    function setZeroTimeoutPostMessage(fn) {\n\t      timeouts.push(fn);\n\t      global.postMessage(messageName, '*');\n\t    }\t\t\n\t\n\t    function handleMessage(event) {\n\t      if (event.source == global && event.data == messageName) {\n\t        if (event.stopPropagation) {\n\t          event.stopPropagation();\n\t        }\n\t        if (timeouts.length) {\n\t          timeouts.shift()();\n\t        }\n\t      }\n\t    }\n\t    if (global.addEventListener) {\n\t      global.addEventListener('message', handleMessage, true);\n\t    } else if (global.attachEvent) {\n\t      global.attachEvent('onmessage', handleMessage);\n\t    }\n\t    return setZeroTimeoutPostMessage;\n\t  }(this)),\n\t  \n\t  blobToArrayBuffer: function(blob, cb){\n\t    var fr = new FileReader();\n\t    fr.onload = function(evt) {\n\t      cb(evt.target.result);\n\t    };\n\t    fr.readAsArrayBuffer(blob);\n\t  },\n\t  blobToBinaryString: function(blob, cb){\n\t    var fr = new FileReader();\n\t    fr.onload = function(evt) {\n\t      cb(evt.target.result);\n\t    };\n\t    fr.readAsBinaryString(blob);\n\t  },\n\t  binaryStringToArrayBuffer: function(binary) {\n\t    var byteArray = new Uint8Array(binary.length);\n\t    for (var i = 0; i < binary.length; i++) {\n\t      byteArray[i] = binary.charCodeAt(i) & 0xff;\n\t    }\n\t    return byteArray.buffer;\n\t  },\n\t  randomToken: function () {\n\t    return Math.random().toString(36).substr(2);\n\t  }\n\t};\n\t\n\tmodule.exports = util;\n\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// peer_web.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 81b94873f4642fb1a79b","var defaultConfig = {'iceServers': [{ 'url': 'stun:stun.l.google.com:19302' }]};\nvar dataCount = 1;\n\nvar BinaryPack = require('js-binarypack');\nvar RTCPeerConnection = require('./adapter').RTCPeerConnection;\n\nvar util = {\n  noop: function() {},\n\n  CLOUD_HOST: '0.peerjs.com',\n  CLOUD_PORT: 9000,\n\n  // Browsers that need chunking:\n  chunkedBrowsers: {'Chrome': 1},\n  chunkedMTU: 16300, // The original 60000 bytes setting does not work when sending data from Firefox to Chrome, which is \"cut off\" after 16384 bytes and delivered individually.\n\n  // Logging logic\n  logLevel: 0,\n  setLogLevel: function(level) {\n    var debugLevel = parseInt(level, 10);\n    if (!isNaN(parseInt(level, 10))) {\n      util.logLevel = debugLevel;\n    } else {\n      // If they are using truthy/falsy values for debug\n      util.logLevel = level ? 3 : 0;\n    }\n    util.log = util.warn = util.error = util.noop;\n    if (util.logLevel > 0) {\n      util.error = util._printWith('ERROR');\n    }\n    if (util.logLevel > 1) {\n      util.warn = util._printWith('WARNING');\n    }\n    if (util.logLevel > 2) {\n      util.log = util._print;\n    }\n  },\n  setLogFunction: function(fn) {\n    if (fn.constructor !== Function) {\n      util.warn('The log function you passed in is not a function. Defaulting to regular logs.');\n    } else {\n      util._print = fn;\n    }\n  },\n\n  _printWith: function(prefix) {\n    return function() {\n      var copy = Array.prototype.slice.call(arguments);\n      copy.unshift(prefix);\n      util._print.apply(util, copy);\n    };\n  },\n  _print: function () {\n    var err = false;\n    var copy = Array.prototype.slice.call(arguments);\n    copy.unshift('PeerJS: ');\n    for (var i = 0, l = copy.length; i < l; i++){\n      if (copy[i] instanceof Error) {\n        copy[i] = '(' + copy[i].name + ') ' + copy[i].message;\n        err = true;\n      }\n    }\n    err ? console.error.apply(console, copy) : console.log.apply(console, copy);\n  },\n  //\n\n  // Returns browser-agnostic default config\n  defaultConfig: defaultConfig,\n  //\n\n  // Returns the current browser.\n  browser: (function() {\n    if (window.mozRTCPeerConnection) {\n      return 'Firefox';\n    } else if (window.webkitRTCPeerConnection) {\n      return 'Chrome';\n    } else if (window.RTCPeerConnection) {\n      return 'Supported';\n    } else {\n      return 'Unsupported';\n    }\n  })(),\n  //\n\n  // Lists which features are supported\n  supports: (function() {\n    if (typeof RTCPeerConnection === 'undefined') {\n      return {};\n    }\n\n    var data = true;\n    var audioVideo = true;\n\n    var binaryBlob = false;\n    var sctp = false;\n    var onnegotiationneeded = !!window.webkitRTCPeerConnection;\n\n    var pc, dc;\n    try {\n      pc = new RTCPeerConnection(defaultConfig, {optional: [{RtpDataChannels: true}]});\n    } catch (e) {\n      data = false;\n      audioVideo = false;\n    }\n\n    if (data) {\n      try {\n        dc = pc.createDataChannel('_PEERJSTEST');\n      } catch (e) {\n        data = false;\n      }\n    }\n\n    if (data) {\n      // Binary test\n      try {\n        dc.binaryType = 'blob';\n        binaryBlob = true;\n      } catch (e) {\n      }\n\n      // Reliable test.\n      // Unfortunately Chrome is a bit unreliable about whether or not they\n      // support reliable.\n      var reliablePC = new RTCPeerConnection(defaultConfig, {});\n      try {\n        var reliableDC = reliablePC.createDataChannel('_PEERJSRELIABLETEST', {});\n        sctp = reliableDC.reliable;\n      } catch (e) {\n      }\n      reliablePC.close();\n    }\n\n    // FIXME: not really the best check...\n    if (audioVideo) {\n      audioVideo = !!pc.addStream;\n    }\n\n    // FIXME: this is not great because in theory it doesn't work for\n    // av-only browsers (?).\n    if (!onnegotiationneeded && data) {\n      // sync default check.\n      var negotiationPC = new RTCPeerConnection(defaultConfig, {optional: [{RtpDataChannels: true}]});\n      negotiationPC.onnegotiationneeded = function() {\n        onnegotiationneeded = true;\n        // async check.\n        if (util && util.supports) {\n          util.supports.onnegotiationneeded = true;\n        }\n      };\n      negotiationPC.createDataChannel('_PEERJSNEGOTIATIONTEST');\n\n      setTimeout(function() {\n        negotiationPC.close();\n      }, 1000);\n    }\n\n    if (pc) {\n      pc.close();\n    }\n\n    return {\n      audioVideo: audioVideo,\n      data: data,\n      binaryBlob: binaryBlob,\n      binary: sctp, // deprecated; sctp implies binary support.\n      reliable: sctp, // deprecated; sctp implies reliable data.\n      sctp: sctp,\n      onnegotiationneeded: onnegotiationneeded\n    };\n  }()),\n  //\n\n  // Ensure alphanumeric ids\n  validateId: function(id) {\n    // Allow empty ids\n    return !id || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(id);\n  },\n\n  validateKey: function(key) {\n    // Allow empty keys\n    return !key || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(key);\n  },\n\n\n  debug: false,\n\n  inherits: function(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  },\n  extend: function(dest, source) {\n    for(var key in source) {\n      if(source.hasOwnProperty(key)) {\n        dest[key] = source[key];\n      }\n    }\n    return dest;\n  },\n  pack: BinaryPack.pack,\n  unpack: BinaryPack.unpack,\n\n  log: function () {\n    if (util.debug) {\n      var err = false;\n      var copy = Array.prototype.slice.call(arguments);\n      copy.unshift('PeerJS: ');\n      for (var i = 0, l = copy.length; i < l; i++){\n        if (copy[i] instanceof Error) {\n          copy[i] = '(' + copy[i].name + ') ' + copy[i].message;\n          err = true;\n        }\n      }\n      err ? console.error.apply(console, copy) : console.log.apply(console, copy);\n    }\n  },\n\n  setZeroTimeout: (function(global) {\n    var timeouts = [];\n    var messageName = 'zero-timeout-message';\n\n    // Like setTimeout, but only takes a function argument.\t There's\n    // no time argument (always zero) and no arguments (you have to\n    // use a closure).\n    function setZeroTimeoutPostMessage(fn) {\n      timeouts.push(fn);\n      global.postMessage(messageName, '*');\n    }\n\n    function handleMessage(event) {\n      if (event.source == global && event.data == messageName) {\n        if (event.stopPropagation) {\n          event.stopPropagation();\n        }\n        if (timeouts.length) {\n          timeouts.shift()();\n        }\n      }\n    }\n    if (global.addEventListener) {\n      global.addEventListener('message', handleMessage, true);\n    } else if (global.attachEvent) {\n      global.attachEvent('onmessage', handleMessage);\n    }\n    return setZeroTimeoutPostMessage;\n  }(window)),\n\n  // Binary stuff\n\n  // chunks a blob.\n  chunk: function(bl) {\n    var chunks = [];\n    var size = bl.size;\n    var start = index = 0;\n    var total = Math.ceil(size / util.chunkedMTU);\n    while (start < size) {\n      var end = Math.min(size, start + util.chunkedMTU);\n      var b = bl.slice(start, end);\n\n      var chunk = {\n        __peerData: dataCount,\n        n: index,\n        data: b,\n        total: total\n      };\n\n      chunks.push(chunk);\n\n      start = end;\n      index += 1;\n    }\n    dataCount += 1;\n    return chunks;\n  },\n\n  blobToArrayBuffer: function(blob, cb){\n    var fr = new FileReader();\n    fr.onload = function(evt) {\n      cb(evt.target.result);\n    };\n    fr.readAsArrayBuffer(blob);\n  },\n  blobToBinaryString: function(blob, cb){\n    var fr = new FileReader();\n    fr.onload = function(evt) {\n      cb(evt.target.result);\n    };\n    fr.readAsBinaryString(blob);\n  },\n  binaryStringToArrayBuffer: function(binary) {\n    var byteArray = new Uint8Array(binary.length);\n    for (var i = 0; i < binary.length; i++) {\n      byteArray[i] = binary.charCodeAt(i) & 0xff;\n    }\n    return byteArray.buffer;\n  },\n  randomToken: function () {\n    return Math.random().toString(36).substr(2);\n  },\n  //\n\n  isSecure: function() {\n    return location.protocol === 'https:';\n  }\n};\n\nmodule.exports = util;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/peerjs/lib/util.js\n// module id = 1\n// module chunks = 0","module.exports.RTCSessionDescription = window.RTCSessionDescription ||\n\twindow.mozRTCSessionDescription;\nmodule.exports.RTCPeerConnection = window.RTCPeerConnection ||\n\twindow.mozRTCPeerConnection || window.webkitRTCPeerConnection;\nmodule.exports.RTCIceCandidate = window.RTCIceCandidate ||\n\twindow.mozRTCIceCandidate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/peerjs/lib/adapter.js\n// module id = 2\n// module chunks = 0","'use strict';\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  if (!this._events || !this._events[event]) return [];\n  if (this._events[event].fn) return [this._events[event].fn];\n\n  for (var i = 0, l = this._events[event].length, ee = new Array(l); i < l; i++) {\n    ee[i] = this._events[event][i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  if (!this._events || !this._events[event]) return false;\n\n  var listeners = this._events[event]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this);\n\n  if (!this._events) this._events = {};\n  if (!this._events[event]) this._events[event] = listener;\n  else {\n    if (!this._events[event].fn) this._events[event].push(listener);\n    else this._events[event] = [\n      this._events[event], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true);\n\n  if (!this._events) this._events = {};\n  if (!this._events[event]) this._events[event] = listener;\n  else {\n    if (!this._events[event].fn) this._events[event].push(listener);\n    else this._events[event] = [\n      this._events[event], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, once) {\n  if (!this._events || !this._events[event]) return this;\n\n  var listeners = this._events[event]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn && (listeners.fn !== fn || (once && !listeners.once))) {\n      events.push(listeners);\n    }\n    if (!listeners.fn) for (var i = 0, length = listeners.length; i < length; i++) {\n      if (listeners[i].fn !== fn || (once && !listeners[i].once)) {\n        events.push(listeners[i]);\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[event] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[event];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[event];\n  else this._events = {};\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the module.\n//\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.EventEmitter2 = EventEmitter;\nEventEmitter.EventEmitter3 = EventEmitter;\n\n//\n// Expose the module.\n//\nmodule.exports = EventEmitter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/peerjs/~/eventemitter3/index.js\n// module id = 3\n// module chunks = 0","var BufferBuilder = require('./bufferbuilder').BufferBuilder;\r\nvar binaryFeatures = require('./bufferbuilder').binaryFeatures;\r\n\r\nvar BinaryPack = {\r\n  unpack: function(data){\r\n    var unpacker = new Unpacker(data);\r\n    return unpacker.unpack();\r\n  },\r\n  pack: function(data){\r\n    var packer = new Packer();\r\n    packer.pack(data);\r\n    var buffer = packer.getBuffer();\r\n    return buffer;\r\n  }\r\n};\r\n\r\nmodule.exports = BinaryPack;\r\n\r\nfunction Unpacker (data){\r\n  // Data is ArrayBuffer\r\n  this.index = 0;\r\n  this.dataBuffer = data;\r\n  this.dataView = new Uint8Array(this.dataBuffer);\r\n  this.length = this.dataBuffer.byteLength;\r\n}\r\n\r\nUnpacker.prototype.unpack = function(){\r\n  var type = this.unpack_uint8();\r\n  if (type < 0x80){\r\n    var positive_fixnum = type;\r\n    return positive_fixnum;\r\n  } else if ((type ^ 0xe0) < 0x20){\r\n    var negative_fixnum = (type ^ 0xe0) - 0x20;\r\n    return negative_fixnum;\r\n  }\r\n  var size;\r\n  if ((size = type ^ 0xa0) <= 0x0f){\r\n    return this.unpack_raw(size);\r\n  } else if ((size = type ^ 0xb0) <= 0x0f){\r\n    return this.unpack_string(size);\r\n  } else if ((size = type ^ 0x90) <= 0x0f){\r\n    return this.unpack_array(size);\r\n  } else if ((size = type ^ 0x80) <= 0x0f){\r\n    return this.unpack_map(size);\r\n  }\r\n  switch(type){\r\n    case 0xc0:\r\n      return null;\r\n    case 0xc1:\r\n      return undefined;\r\n    case 0xc2:\r\n      return false;\r\n    case 0xc3:\r\n      return true;\r\n    case 0xca:\r\n      return this.unpack_float();\r\n    case 0xcb:\r\n      return this.unpack_double();\r\n    case 0xcc:\r\n      return this.unpack_uint8();\r\n    case 0xcd:\r\n      return this.unpack_uint16();\r\n    case 0xce:\r\n      return this.unpack_uint32();\r\n    case 0xcf:\r\n      return this.unpack_uint64();\r\n    case 0xd0:\r\n      return this.unpack_int8();\r\n    case 0xd1:\r\n      return this.unpack_int16();\r\n    case 0xd2:\r\n      return this.unpack_int32();\r\n    case 0xd3:\r\n      return this.unpack_int64();\r\n    case 0xd4:\r\n      return undefined;\r\n    case 0xd5:\r\n      return undefined;\r\n    case 0xd6:\r\n      return undefined;\r\n    case 0xd7:\r\n      return undefined;\r\n    case 0xd8:\r\n      size = this.unpack_uint16();\r\n      return this.unpack_string(size);\r\n    case 0xd9:\r\n      size = this.unpack_uint32();\r\n      return this.unpack_string(size);\r\n    case 0xda:\r\n      size = this.unpack_uint16();\r\n      return this.unpack_raw(size);\r\n    case 0xdb:\r\n      size = this.unpack_uint32();\r\n      return this.unpack_raw(size);\r\n    case 0xdc:\r\n      size = this.unpack_uint16();\r\n      return this.unpack_array(size);\r\n    case 0xdd:\r\n      size = this.unpack_uint32();\r\n      return this.unpack_array(size);\r\n    case 0xde:\r\n      size = this.unpack_uint16();\r\n      return this.unpack_map(size);\r\n    case 0xdf:\r\n      size = this.unpack_uint32();\r\n      return this.unpack_map(size);\r\n  }\r\n}\r\n\r\nUnpacker.prototype.unpack_uint8 = function(){\r\n  var byte = this.dataView[this.index] & 0xff;\r\n  this.index++;\r\n  return byte;\r\n};\r\n\r\nUnpacker.prototype.unpack_uint16 = function(){\r\n  var bytes = this.read(2);\r\n  var uint16 =\r\n    ((bytes[0] & 0xff) * 256) + (bytes[1] & 0xff);\r\n  this.index += 2;\r\n  return uint16;\r\n}\r\n\r\nUnpacker.prototype.unpack_uint32 = function(){\r\n  var bytes = this.read(4);\r\n  var uint32 =\r\n     ((bytes[0]  * 256 +\r\n       bytes[1]) * 256 +\r\n       bytes[2]) * 256 +\r\n       bytes[3];\r\n  this.index += 4;\r\n  return uint32;\r\n}\r\n\r\nUnpacker.prototype.unpack_uint64 = function(){\r\n  var bytes = this.read(8);\r\n  var uint64 =\r\n   ((((((bytes[0]  * 256 +\r\n       bytes[1]) * 256 +\r\n       bytes[2]) * 256 +\r\n       bytes[3]) * 256 +\r\n       bytes[4]) * 256 +\r\n       bytes[5]) * 256 +\r\n       bytes[6]) * 256 +\r\n       bytes[7];\r\n  this.index += 8;\r\n  return uint64;\r\n}\r\n\r\n\r\nUnpacker.prototype.unpack_int8 = function(){\r\n  var uint8 = this.unpack_uint8();\r\n  return (uint8 < 0x80 ) ? uint8 : uint8 - (1 << 8);\r\n};\r\n\r\nUnpacker.prototype.unpack_int16 = function(){\r\n  var uint16 = this.unpack_uint16();\r\n  return (uint16 < 0x8000 ) ? uint16 : uint16 - (1 << 16);\r\n}\r\n\r\nUnpacker.prototype.unpack_int32 = function(){\r\n  var uint32 = this.unpack_uint32();\r\n  return (uint32 < Math.pow(2, 31) ) ? uint32 :\r\n    uint32 - Math.pow(2, 32);\r\n}\r\n\r\nUnpacker.prototype.unpack_int64 = function(){\r\n  var uint64 = this.unpack_uint64();\r\n  return (uint64 < Math.pow(2, 63) ) ? uint64 :\r\n    uint64 - Math.pow(2, 64);\r\n}\r\n\r\nUnpacker.prototype.unpack_raw = function(size){\r\n  if ( this.length < this.index + size){\r\n    throw new Error('BinaryPackFailure: index is out of range'\r\n      + ' ' + this.index + ' ' + size + ' ' + this.length);\r\n  }\r\n  var buf = this.dataBuffer.slice(this.index, this.index + size);\r\n  this.index += size;\r\n\r\n    //buf = util.bufferToString(buf);\r\n\r\n  return buf;\r\n}\r\n\r\nUnpacker.prototype.unpack_string = function(size){\r\n  var bytes = this.read(size);\r\n  var i = 0, str = '', c, code;\r\n  while(i < size){\r\n    c = bytes[i];\r\n    if ( c < 128){\r\n      str += String.fromCharCode(c);\r\n      i++;\r\n    } else if ((c ^ 0xc0) < 32){\r\n      code = ((c ^ 0xc0) << 6) | (bytes[i+1] & 63);\r\n      str += String.fromCharCode(code);\r\n      i += 2;\r\n    } else {\r\n      code = ((c & 15) << 12) | ((bytes[i+1] & 63) << 6) |\r\n        (bytes[i+2] & 63);\r\n      str += String.fromCharCode(code);\r\n      i += 3;\r\n    }\r\n  }\r\n  this.index += size;\r\n  return str;\r\n}\r\n\r\nUnpacker.prototype.unpack_array = function(size){\r\n  var objects = new Array(size);\r\n  for(var i = 0; i < size ; i++){\r\n    objects[i] = this.unpack();\r\n  }\r\n  return objects;\r\n}\r\n\r\nUnpacker.prototype.unpack_map = function(size){\r\n  var map = {};\r\n  for(var i = 0; i < size ; i++){\r\n    var key  = this.unpack();\r\n    var value = this.unpack();\r\n    map[key] = value;\r\n  }\r\n  return map;\r\n}\r\n\r\nUnpacker.prototype.unpack_float = function(){\r\n  var uint32 = this.unpack_uint32();\r\n  var sign = uint32 >> 31;\r\n  var exp  = ((uint32 >> 23) & 0xff) - 127;\r\n  var fraction = ( uint32 & 0x7fffff ) | 0x800000;\r\n  return (sign == 0 ? 1 : -1) *\r\n    fraction * Math.pow(2, exp - 23);\r\n}\r\n\r\nUnpacker.prototype.unpack_double = function(){\r\n  var h32 = this.unpack_uint32();\r\n  var l32 = this.unpack_uint32();\r\n  var sign = h32 >> 31;\r\n  var exp  = ((h32 >> 20) & 0x7ff) - 1023;\r\n  var hfrac = ( h32 & 0xfffff ) | 0x100000;\r\n  var frac = hfrac * Math.pow(2, exp - 20) +\r\n    l32   * Math.pow(2, exp - 52);\r\n  return (sign == 0 ? 1 : -1) * frac;\r\n}\r\n\r\nUnpacker.prototype.read = function(length){\r\n  var j = this.index;\r\n  if (j + length <= this.length) {\r\n    return this.dataView.subarray(j, j + length);\r\n  } else {\r\n    throw new Error('BinaryPackFailure: read index out of range');\r\n  }\r\n}\r\n\r\nfunction Packer(){\r\n  this.bufferBuilder = new BufferBuilder();\r\n}\r\n\r\nPacker.prototype.getBuffer = function(){\r\n  return this.bufferBuilder.getBuffer();\r\n}\r\n\r\nPacker.prototype.pack = function(value){\r\n  var type = typeof(value);\r\n  if (type == 'string'){\r\n    this.pack_string(value);\r\n  } else if (type == 'number'){\r\n    if (Math.floor(value) === value){\r\n      this.pack_integer(value);\r\n    } else{\r\n      this.pack_double(value);\r\n    }\r\n  } else if (type == 'boolean'){\r\n    if (value === true){\r\n      this.bufferBuilder.append(0xc3);\r\n    } else if (value === false){\r\n      this.bufferBuilder.append(0xc2);\r\n    }\r\n  } else if (type == 'undefined'){\r\n    this.bufferBuilder.append(0xc0);\r\n  } else if (type == 'object'){\r\n    if (value === null){\r\n      this.bufferBuilder.append(0xc0);\r\n    } else {\r\n      var constructor = value.constructor;\r\n      if (constructor == Array){\r\n        this.pack_array(value);\r\n      } else if (constructor == Blob || constructor == File) {\r\n        this.pack_bin(value);\r\n      } else if (constructor == ArrayBuffer) {\r\n        if(binaryFeatures.useArrayBufferView) {\r\n          this.pack_bin(new Uint8Array(value));\r\n        } else {\r\n          this.pack_bin(value);\r\n        }\r\n      } else if ('BYTES_PER_ELEMENT' in value){\r\n        if(binaryFeatures.useArrayBufferView) {\r\n          this.pack_bin(new Uint8Array(value.buffer));\r\n        } else {\r\n          this.pack_bin(value.buffer);\r\n        }\r\n      } else if (constructor == Object){\r\n        this.pack_object(value);\r\n      } else if (constructor == Date){\r\n        this.pack_string(value.toString());\r\n      } else if (typeof value.toBinaryPack == 'function'){\r\n        this.bufferBuilder.append(value.toBinaryPack());\r\n      } else {\r\n        throw new Error('Type \"' + constructor.toString() + '\" not yet supported');\r\n      }\r\n    }\r\n  } else {\r\n    throw new Error('Type \"' + type + '\" not yet supported');\r\n  }\r\n  this.bufferBuilder.flush();\r\n}\r\n\r\n\r\nPacker.prototype.pack_bin = function(blob){\r\n  var length = blob.length || blob.byteLength || blob.size;\r\n  if (length <= 0x0f){\r\n    this.pack_uint8(0xa0 + length);\r\n  } else if (length <= 0xffff){\r\n    this.bufferBuilder.append(0xda) ;\r\n    this.pack_uint16(length);\r\n  } else if (length <= 0xffffffff){\r\n    this.bufferBuilder.append(0xdb);\r\n    this.pack_uint32(length);\r\n  } else{\r\n    throw new Error('Invalid length');\r\n  }\r\n  this.bufferBuilder.append(blob);\r\n}\r\n\r\nPacker.prototype.pack_string = function(str){\r\n  var length = utf8Length(str);\r\n\r\n  if (length <= 0x0f){\r\n    this.pack_uint8(0xb0 + length);\r\n  } else if (length <= 0xffff){\r\n    this.bufferBuilder.append(0xd8) ;\r\n    this.pack_uint16(length);\r\n  } else if (length <= 0xffffffff){\r\n    this.bufferBuilder.append(0xd9);\r\n    this.pack_uint32(length);\r\n  } else{\r\n    throw new Error('Invalid length');\r\n  }\r\n  this.bufferBuilder.append(str);\r\n}\r\n\r\nPacker.prototype.pack_array = function(ary){\r\n  var length = ary.length;\r\n  if (length <= 0x0f){\r\n    this.pack_uint8(0x90 + length);\r\n  } else if (length <= 0xffff){\r\n    this.bufferBuilder.append(0xdc)\r\n    this.pack_uint16(length);\r\n  } else if (length <= 0xffffffff){\r\n    this.bufferBuilder.append(0xdd);\r\n    this.pack_uint32(length);\r\n  } else{\r\n    throw new Error('Invalid length');\r\n  }\r\n  for(var i = 0; i < length ; i++){\r\n    this.pack(ary[i]);\r\n  }\r\n}\r\n\r\nPacker.prototype.pack_integer = function(num){\r\n  if ( -0x20 <= num && num <= 0x7f){\r\n    this.bufferBuilder.append(num & 0xff);\r\n  } else if (0x00 <= num && num <= 0xff){\r\n    this.bufferBuilder.append(0xcc);\r\n    this.pack_uint8(num);\r\n  } else if (-0x80 <= num && num <= 0x7f){\r\n    this.bufferBuilder.append(0xd0);\r\n    this.pack_int8(num);\r\n  } else if ( 0x0000 <= num && num <= 0xffff){\r\n    this.bufferBuilder.append(0xcd);\r\n    this.pack_uint16(num);\r\n  } else if (-0x8000 <= num && num <= 0x7fff){\r\n    this.bufferBuilder.append(0xd1);\r\n    this.pack_int16(num);\r\n  } else if ( 0x00000000 <= num && num <= 0xffffffff){\r\n    this.bufferBuilder.append(0xce);\r\n    this.pack_uint32(num);\r\n  } else if (-0x80000000 <= num && num <= 0x7fffffff){\r\n    this.bufferBuilder.append(0xd2);\r\n    this.pack_int32(num);\r\n  } else if (-0x8000000000000000 <= num && num <= 0x7FFFFFFFFFFFFFFF){\r\n    this.bufferBuilder.append(0xd3);\r\n    this.pack_int64(num);\r\n  } else if (0x0000000000000000 <= num && num <= 0xFFFFFFFFFFFFFFFF){\r\n    this.bufferBuilder.append(0xcf);\r\n    this.pack_uint64(num);\r\n  } else{\r\n    throw new Error('Invalid integer');\r\n  }\r\n}\r\n\r\nPacker.prototype.pack_double = function(num){\r\n  var sign = 0;\r\n  if (num < 0){\r\n    sign = 1;\r\n    num = -num;\r\n  }\r\n  var exp  = Math.floor(Math.log(num) / Math.LN2);\r\n  var frac0 = num / Math.pow(2, exp) - 1;\r\n  var frac1 = Math.floor(frac0 * Math.pow(2, 52));\r\n  var b32   = Math.pow(2, 32);\r\n  var h32 = (sign << 31) | ((exp+1023) << 20) |\r\n      (frac1 / b32) & 0x0fffff;\r\n  var l32 = frac1 % b32;\r\n  this.bufferBuilder.append(0xcb);\r\n  this.pack_int32(h32);\r\n  this.pack_int32(l32);\r\n}\r\n\r\nPacker.prototype.pack_object = function(obj){\r\n  var keys = Object.keys(obj);\r\n  var length = keys.length;\r\n  if (length <= 0x0f){\r\n    this.pack_uint8(0x80 + length);\r\n  } else if (length <= 0xffff){\r\n    this.bufferBuilder.append(0xde);\r\n    this.pack_uint16(length);\r\n  } else if (length <= 0xffffffff){\r\n    this.bufferBuilder.append(0xdf);\r\n    this.pack_uint32(length);\r\n  } else{\r\n    throw new Error('Invalid length');\r\n  }\r\n  for(var prop in obj){\r\n    if (obj.hasOwnProperty(prop)){\r\n      this.pack(prop);\r\n      this.pack(obj[prop]);\r\n    }\r\n  }\r\n}\r\n\r\nPacker.prototype.pack_uint8 = function(num){\r\n  this.bufferBuilder.append(num);\r\n}\r\n\r\nPacker.prototype.pack_uint16 = function(num){\r\n  this.bufferBuilder.append(num >> 8);\r\n  this.bufferBuilder.append(num & 0xff);\r\n}\r\n\r\nPacker.prototype.pack_uint32 = function(num){\r\n  var n = num & 0xffffffff;\r\n  this.bufferBuilder.append((n & 0xff000000) >>> 24);\r\n  this.bufferBuilder.append((n & 0x00ff0000) >>> 16);\r\n  this.bufferBuilder.append((n & 0x0000ff00) >>>  8);\r\n  this.bufferBuilder.append((n & 0x000000ff));\r\n}\r\n\r\nPacker.prototype.pack_uint64 = function(num){\r\n  var high = num / Math.pow(2, 32);\r\n  var low  = num % Math.pow(2, 32);\r\n  this.bufferBuilder.append((high & 0xff000000) >>> 24);\r\n  this.bufferBuilder.append((high & 0x00ff0000) >>> 16);\r\n  this.bufferBuilder.append((high & 0x0000ff00) >>>  8);\r\n  this.bufferBuilder.append((high & 0x000000ff));\r\n  this.bufferBuilder.append((low  & 0xff000000) >>> 24);\r\n  this.bufferBuilder.append((low  & 0x00ff0000) >>> 16);\r\n  this.bufferBuilder.append((low  & 0x0000ff00) >>>  8);\r\n  this.bufferBuilder.append((low  & 0x000000ff));\r\n}\r\n\r\nPacker.prototype.pack_int8 = function(num){\r\n  this.bufferBuilder.append(num & 0xff);\r\n}\r\n\r\nPacker.prototype.pack_int16 = function(num){\r\n  this.bufferBuilder.append((num & 0xff00) >> 8);\r\n  this.bufferBuilder.append(num & 0xff);\r\n}\r\n\r\nPacker.prototype.pack_int32 = function(num){\r\n  this.bufferBuilder.append((num >>> 24) & 0xff);\r\n  this.bufferBuilder.append((num & 0x00ff0000) >>> 16);\r\n  this.bufferBuilder.append((num & 0x0000ff00) >>> 8);\r\n  this.bufferBuilder.append((num & 0x000000ff));\r\n}\r\n\r\nPacker.prototype.pack_int64 = function(num){\r\n  var high = Math.floor(num / Math.pow(2, 32));\r\n  var low  = num % Math.pow(2, 32);\r\n  this.bufferBuilder.append((high & 0xff000000) >>> 24);\r\n  this.bufferBuilder.append((high & 0x00ff0000) >>> 16);\r\n  this.bufferBuilder.append((high & 0x0000ff00) >>>  8);\r\n  this.bufferBuilder.append((high & 0x000000ff));\r\n  this.bufferBuilder.append((low  & 0xff000000) >>> 24);\r\n  this.bufferBuilder.append((low  & 0x00ff0000) >>> 16);\r\n  this.bufferBuilder.append((low  & 0x0000ff00) >>>  8);\r\n  this.bufferBuilder.append((low  & 0x000000ff));\r\n}\r\n\r\nfunction _utf8Replace(m){\r\n  var code = m.charCodeAt(0);\r\n\r\n  if(code <= 0x7ff) return '00';\r\n  if(code <= 0xffff) return '000';\r\n  if(code <= 0x1fffff) return '0000';\r\n  if(code <= 0x3ffffff) return '00000';\r\n  return '000000';\r\n}\r\n\r\nfunction utf8Length(str){\r\n  if (str.length > 600) {\r\n    // Blob method faster for large strings\r\n    return (new Blob([str])).size;\r\n  } else {\r\n    return str.replace(/[^\\u0000-\\u007F]/g, _utf8Replace).length;\r\n  }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/js-binarypack/lib/binarypack.js\n// module id = 4\n// module chunks = 0","var binaryFeatures = {};\r\nbinaryFeatures.useBlobBuilder = (function(){\r\n  try {\r\n    new Blob([]);\r\n    return false;\r\n  } catch (e) {\r\n    return true;\r\n  }\r\n})();\r\n\r\nbinaryFeatures.useArrayBufferView = !binaryFeatures.useBlobBuilder && (function(){\r\n  try {\r\n    return (new Blob([new Uint8Array([])])).size === 0;\r\n  } catch (e) {\r\n    return true;\r\n  }\r\n})();\r\n\r\nmodule.exports.binaryFeatures = binaryFeatures;\r\nvar BlobBuilder = module.exports.BlobBuilder;\r\nif (typeof window != 'undefined') {\r\n  BlobBuilder = module.exports.BlobBuilder = window.WebKitBlobBuilder ||\r\n    window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder;\r\n}\r\n\r\nfunction BufferBuilder(){\r\n  this._pieces = [];\r\n  this._parts = [];\r\n}\r\n\r\nBufferBuilder.prototype.append = function(data) {\r\n  if(typeof data === 'number') {\r\n    this._pieces.push(data);\r\n  } else {\r\n    this.flush();\r\n    this._parts.push(data);\r\n  }\r\n};\r\n\r\nBufferBuilder.prototype.flush = function() {\r\n  if (this._pieces.length > 0) {\r\n    var buf = new Uint8Array(this._pieces);\r\n    if(!binaryFeatures.useArrayBufferView) {\r\n      buf = buf.buffer;\r\n    }\r\n    this._parts.push(buf);\r\n    this._pieces = [];\r\n  }\r\n};\r\n\r\nBufferBuilder.prototype.getBuffer = function() {\r\n  this.flush();\r\n  if(binaryFeatures.useBlobBuilder) {\r\n    var builder = new BlobBuilder();\r\n    for(var i = 0, ii = this._parts.length; i < ii; i++) {\r\n      builder.append(this._parts[i]);\r\n    }\r\n    return builder.getBlob();\r\n  } else {\r\n    return new Blob(this._parts);\r\n  }\r\n};\r\n\r\nmodule.exports.BufferBuilder = BufferBuilder;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/js-binarypack/lib/bufferbuilder.js\n// module id = 5\n// module chunks = 0","var util = require('./util');\nvar RTCPeerConnection = require('./adapter').RTCPeerConnection;\nvar RTCSessionDescription = require('./adapter').RTCSessionDescription;\nvar RTCIceCandidate = require('./adapter').RTCIceCandidate;\n\n/**\n * Manages all negotiations between Peers.\n */\nvar Negotiator = {\n  pcs: {\n    data: {},\n    media: {}\n  }, // type => {peerId: {pc_id: pc}}.\n  //providers: {}, // provider's id => providers (there may be multiple providers/client.\n  queue: [] // connections that are delayed due to a PC being in use.\n}\n\nNegotiator._idPrefix = 'pc_';\n\n/** Returns a PeerConnection object set up correctly (for data, media). */\nNegotiator.startConnection = function(connection, options) {\n  var pc = Negotiator._getPeerConnection(connection, options);\n\n  if (connection.type === 'media' && options._stream) {\n    // Add the stream.\n    pc.addStream(options._stream);\n  }\n\n  // Set the connection's PC.\n  connection.pc = connection.peerConnection = pc;\n  // What do we need to do now?\n  if (options.originator) {\n    if (connection.type === 'data') {\n      // Create the datachannel.\n      var config = {};\n      // Dropping reliable:false support, since it seems to be crashing\n      // Chrome.\n      /*if (util.supports.sctp && !options.reliable) {\n        // If we have canonical reliable support...\n        config = {maxRetransmits: 0};\n      }*/\n      // Fallback to ensure older browsers don't crash.\n      if (!util.supports.sctp) {\n        config = {reliable: options.reliable};\n      }\n      var dc = pc.createDataChannel(connection.label, config);\n      connection.initialize(dc);\n    }\n\n    if (!util.supports.onnegotiationneeded) {\n      Negotiator._makeOffer(connection);\n    }\n  } else {\n    Negotiator.handleSDP('OFFER', connection, options.sdp);\n  }\n}\n\nNegotiator._getPeerConnection = function(connection, options) {\n  if (!Negotiator.pcs[connection.type]) {\n    util.error(connection.type + ' is not a valid connection type. Maybe you overrode the `type` property somewhere.');\n  }\n\n  if (!Negotiator.pcs[connection.type][connection.peer]) {\n    Negotiator.pcs[connection.type][connection.peer] = {};\n  }\n  var peerConnections = Negotiator.pcs[connection.type][connection.peer];\n\n  var pc;\n  // Not multiplexing while FF and Chrome have not-great support for it.\n  /*if (options.multiplex) {\n    ids = Object.keys(peerConnections);\n    for (var i = 0, ii = ids.length; i < ii; i += 1) {\n      pc = peerConnections[ids[i]];\n      if (pc.signalingState === 'stable') {\n        break; // We can go ahead and use this PC.\n      }\n    }\n  } else */\n  if (options.pc) { // Simplest case: PC id already provided for us.\n    pc = Negotiator.pcs[connection.type][connection.peer][options.pc];\n  }\n\n  if (!pc || pc.signalingState !== 'stable') {\n    pc = Negotiator._startPeerConnection(connection);\n  }\n  return pc;\n}\n\n/*\nNegotiator._addProvider = function(provider) {\n  if ((!provider.id && !provider.disconnected) || !provider.socket.open) {\n    // Wait for provider to obtain an ID.\n    provider.on('open', function(id) {\n      Negotiator._addProvider(provider);\n    });\n  } else {\n    Negotiator.providers[provider.id] = provider;\n  }\n}*/\n\n\n/** Start a PC. */\nNegotiator._startPeerConnection = function(connection) {\n  util.log('Creating RTCPeerConnection.');\n\n  var id = Negotiator._idPrefix + util.randomToken();\n  var optional = {};\n\n  if (connection.type === 'data' && !util.supports.sctp) {\n    optional = {optional: [{RtpDataChannels: true}]};\n  } else if (connection.type === 'media') {\n    // Interop req for chrome.\n    optional = {optional: [{DtlsSrtpKeyAgreement: true}]};\n  }\n\n  var pc = new RTCPeerConnection(connection.provider.options.config, optional);\n  Negotiator.pcs[connection.type][connection.peer][id] = pc;\n\n  Negotiator._setupListeners(connection, pc, id);\n\n  return pc;\n}\n\n/** Set up various WebRTC listeners. */\nNegotiator._setupListeners = function(connection, pc, pc_id) {\n  var peerId = connection.peer;\n  var connectionId = connection.id;\n  var provider = connection.provider;\n\n  // ICE CANDIDATES.\n  util.log('Listening for ICE candidates.');\n  pc.onicecandidate = function(evt) {\n    if (evt.candidate) {\n      util.log('Received ICE candidates for:', connection.peer);\n      provider.socket.send({\n        type: 'CANDIDATE',\n        payload: {\n          candidate: evt.candidate,\n          type: connection.type,\n          connectionId: connection.id\n        },\n        dst: peerId\n      });\n    }\n  };\n\n  pc.oniceconnectionstatechange = function() {\n    switch (pc.iceConnectionState) {\n      case 'disconnected':\n      case 'failed':\n        util.log('iceConnectionState is disconnected, closing connections to ' + peerId);\n        connection.close();\n        break;\n      case 'completed':\n        pc.onicecandidate = util.noop;\n        break;\n    }\n  };\n\n  // Fallback for older Chrome impls.\n  pc.onicechange = pc.oniceconnectionstatechange;\n\n  // ONNEGOTIATIONNEEDED (Chrome)\n  util.log('Listening for `negotiationneeded`');\n  pc.onnegotiationneeded = function() {\n    util.log('`negotiationneeded` triggered');\n    if (pc.signalingState == 'stable') {\n      Negotiator._makeOffer(connection);\n    } else {\n      util.log('onnegotiationneeded triggered when not stable. Is another connection being established?');\n    }\n  };\n\n  // DATACONNECTION.\n  util.log('Listening for data channel');\n  // Fired between offer and answer, so options should already be saved\n  // in the options hash.\n  pc.ondatachannel = function(evt) {\n    util.log('Received data channel');\n    var dc = evt.channel;\n    var connection = provider.getConnection(peerId, connectionId);\n    connection.initialize(dc);\n  };\n\n  // MEDIACONNECTION.\n  util.log('Listening for remote stream');\n  pc.onaddstream = function(evt) {\n    util.log('Received remote stream');\n    var stream = evt.stream;\n    var connection = provider.getConnection(peerId, connectionId);\n    // 10/10/2014: looks like in Chrome 38, onaddstream is triggered after\n    // setting the remote description. Our connection object in these cases\n    // is actually a DATA connection, so addStream fails.\n    // TODO: This is hopefully just a temporary fix. We should try to\n    // understand why this is happening.\n    if (connection.type === 'media') {\n      connection.addStream(stream);\n    }\n  };\n}\n\nNegotiator.cleanup = function(connection) {\n  util.log('Cleaning up PeerConnection to ' + connection.peer);\n\n  var pc = connection.pc;\n\n  if (!!pc && (pc.readyState !== 'closed' || pc.signalingState !== 'closed')) {\n    pc.close();\n    connection.pc = null;\n  }\n}\n\nNegotiator._makeOffer = function(connection) {\n  var pc = connection.pc;\n  pc.createOffer(function(offer) {\n    util.log('Created offer.');\n\n    if (!util.supports.sctp && connection.type === 'data' && connection.reliable) {\n      offer.sdp = Reliable.higherBandwidthSDP(offer.sdp);\n    }\n\n    pc.setLocalDescription(offer, function() {\n      util.log('Set localDescription: offer', 'for:', connection.peer);\n      connection.provider.socket.send({\n        type: 'OFFER',\n        payload: {\n          sdp: offer,\n          type: connection.type,\n          label: connection.label,\n          connectionId: connection.id,\n          reliable: connection.reliable,\n          serialization: connection.serialization,\n          metadata: connection.metadata,\n          browser: util.browser\n        },\n        dst: connection.peer\n      });\n    }, function(err) {\n      connection.provider.emitError('webrtc', err);\n      util.log('Failed to setLocalDescription, ', err);\n    });\n  }, function(err) {\n    connection.provider.emitError('webrtc', err);\n    util.log('Failed to createOffer, ', err);\n  }, connection.options.constraints);\n}\n\nNegotiator._makeAnswer = function(connection) {\n  var pc = connection.pc;\n\n  pc.createAnswer(function(answer) {\n    util.log('Created answer.');\n\n    if (!util.supports.sctp && connection.type === 'data' && connection.reliable) {\n      answer.sdp = Reliable.higherBandwidthSDP(answer.sdp);\n    }\n\n    pc.setLocalDescription(answer, function() {\n      util.log('Set localDescription: answer', 'for:', connection.peer);\n      connection.provider.socket.send({\n        type: 'ANSWER',\n        payload: {\n          sdp: answer,\n          type: connection.type,\n          connectionId: connection.id,\n          browser: util.browser\n        },\n        dst: connection.peer\n      });\n    }, function(err) {\n      connection.provider.emitError('webrtc', err);\n      util.log('Failed to setLocalDescription, ', err);\n    });\n  }, function(err) {\n    connection.provider.emitError('webrtc', err);\n    util.log('Failed to create answer, ', err);\n  });\n}\n\n/** Handle an SDP. */\nNegotiator.handleSDP = function(type, connection, sdp) {\n  sdp = new RTCSessionDescription(sdp);\n  var pc = connection.pc;\n\n  util.log('Setting remote description', sdp);\n  pc.setRemoteDescription(sdp, function() {\n    util.log('Set remoteDescription:', type, 'for:', connection.peer);\n\n    if (type === 'OFFER') {\n      Negotiator._makeAnswer(connection);\n    }\n  }, function(err) {\n    connection.provider.emitError('webrtc', err);\n    util.log('Failed to setRemoteDescription, ', err);\n  });\n}\n\n/** Handle a candidate. */\nNegotiator.handleCandidate = function(connection, ice) {\n  var candidate = ice.candidate;\n  var sdpMLineIndex = ice.sdpMLineIndex;\n  connection.pc.addIceCandidate(new RTCIceCandidate({\n    sdpMLineIndex: sdpMLineIndex,\n    candidate: candidate\n  }));\n  util.log('Added ICE candidate for:', connection.peer);\n}\n\nmodule.exports = Negotiator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/peerjs/lib/negotiator.js\n// module id = 6\n// module chunks = 0","import Peer from 'peerjs';\n/* eslint-disable no-console */\nexport default function PeerWeb(key, existingPeer){\n  if (this.constructor !== PeerWeb) return new PeerWeb(key, existingPeer);\n\n  // Private Vars\n  const peer = existingPeer || new Peer({ key }); // , debug: 3 });\n  this.peer = peer;\n  const potentialPeers = [];\n  const connections = [];\n\n  // Private Functions\n  function trigger(action, ...args){\n    callbacks[action].forEach(cb => cb.apply(null, args));\n  }\n  function tryPotentialPeers(){\n    if (peer.disconnected) return;\n    potentialPeers.forEach(function(peerId){\n      setupConnection( peer.connect(peerId) );\n    });\n    potentialPeers.splice(0);\n  }\n  function setupConnection(connection){\n    connection.on('open', ()=>{\n      connections.push(connection);\n      trigger('Connected', connection.peer);\n    });\n    connection.on('data', trigger.bind(null, 'Data'));\n    connection.on('close', ()=>{\n      const index = connections.indexOf(connection);\n      if (index === -1) { console.log('connection on close not in connections'); debugger; return; }\n      connections.splice(index, 1);\n      trigger('Disconnected', connection.peer);\n    });\n    connection.on('error', error => { console.log('connection on error', connection, error); debugger; });\n  }\n\n  // Initialize\n  peer.on('open', id => {\n    trigger('Open', id);\n    tryPotentialPeers();\n  });\n  peer.on('connection', setupConnection);\n  peer.on('close', ()=>{ console.log('peer on close', peer); }); // lost connections, should call `peer.destroy()`\n  peer.on('disconnected', ()=>{ trigger('Close'); }); // no new connections, but keeps existing connections, should call `peer.reconnect()`\n  peer.on('error', error => {\n    var a = {\n      'peer-unavailable': ()=>{ trigger('Unavailable', error.message.match(/Could not connect to peer (.+)$/)[1]); }\n    }[error.type];\n    if (a) a(error);\n    else console.error('Unknown peer error: '+error.type, error);\n  });\n\n  // Public Functions\n  this.addPeer = peerId => {\n    potentialPeers.push(peerId);\n    tryPotentialPeers();\n  };\n  this.send = (...args) =>{\n    connections.forEach(connection => connection.send(...args));\n  };\n  this.reconnect = peer.reconnect;\n  this.destroy = peer.destroy;\n  const callbacks = {};\n  Object.keys(PeerWeb.actions).forEach(action => {\n    callbacks[action] = [];\n    this[`on${action}`] = cb => { callbacks[action].push(cb); };\n    this[`off${action}`] = cb => {\n      if (cb) {\n        const index = callbacks[action].indexOf(cb);\n        if (index === -1) return 0;\n        return callbacks[action].splice(index, 1).length;\n      } else {\n        return callbacks[action].splice(0).length;\n      }\n    };\n  });\n}\n// Callback API\nPeerWeb.actions = {\n  'Open': ['peerId'],\n  'Connected': ['connectedPeerId'],\n  'Data': ['data'],\n  'Disconnected': ['connectedPeerId'],\n  'Close': [],\n  'Unavailable': ['connectedPeerId']\n};\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","module.exports = global[\"PeerWeb\"] = require(\"-!/Users/doug.meyer/Code/Personal/PeerWeb/node_modules/babel-loader/lib/index.js?presets=es2015!/Users/doug.meyer/Code/Personal/PeerWeb/index.js\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.js\n// module id = 8\n// module chunks = 0","var util = require('./util');\nvar EventEmitter = require('eventemitter3');\nvar Negotiator = require('./negotiator');\nvar Reliable = require('reliable');\n\n/**\n * Wraps a DataChannel between two Peers.\n */\nfunction DataConnection(peer, provider, options) {\n  if (!(this instanceof DataConnection)) return new DataConnection(peer, provider, options);\n  EventEmitter.call(this);\n\n  this.options = util.extend({\n    serialization: 'binary',\n    reliable: false\n  }, options);\n\n  // Connection is not open yet.\n  this.open = false;\n  this.type = 'data';\n  this.peer = peer;\n  this.provider = provider;\n\n  this.id = this.options.connectionId || DataConnection._idPrefix + util.randomToken();\n\n  this.label = this.options.label || this.id;\n  this.metadata = this.options.metadata;\n  this.serialization = this.options.serialization;\n  this.reliable = this.options.reliable;\n\n  // Data channel buffering.\n  this._buffer = [];\n  this._buffering = false;\n  this.bufferSize = 0;\n\n  // For storing large data.\n  this._chunkedData = {};\n\n  if (this.options._payload) {\n    this._peerBrowser = this.options._payload.browser;\n  }\n\n  Negotiator.startConnection(\n    this,\n    this.options._payload || {\n      originator: true\n    }\n  );\n}\n\nutil.inherits(DataConnection, EventEmitter);\n\nDataConnection._idPrefix = 'dc_';\n\n/** Called by the Negotiator when the DataChannel is ready. */\nDataConnection.prototype.initialize = function(dc) {\n  this._dc = this.dataChannel = dc;\n  this._configureDataChannel();\n}\n\nDataConnection.prototype._configureDataChannel = function() {\n  var self = this;\n  if (util.supports.sctp) {\n    this._dc.binaryType = 'arraybuffer';\n  }\n  this._dc.onopen = function() {\n    util.log('Data channel connection success');\n    self.open = true;\n    self.emit('open');\n  }\n\n  // Use the Reliable shim for non Firefox browsers\n  if (!util.supports.sctp && this.reliable) {\n    this._reliable = new Reliable(this._dc, util.debug);\n  }\n\n  if (this._reliable) {\n    this._reliable.onmessage = function(msg) {\n      self.emit('data', msg);\n    };\n  } else {\n    this._dc.onmessage = function(e) {\n      self._handleDataMessage(e);\n    };\n  }\n  this._dc.onclose = function(e) {\n    util.log('DataChannel closed for:', self.peer);\n    self.close();\n  };\n}\n\n// Handles a DataChannel message.\nDataConnection.prototype._handleDataMessage = function(e) {\n  var self = this;\n  var data = e.data;\n  var datatype = data.constructor;\n  if (this.serialization === 'binary' || this.serialization === 'binary-utf8') {\n    if (datatype === Blob) {\n      // Datatype should never be blob\n      util.blobToArrayBuffer(data, function(ab) {\n        data = util.unpack(ab);\n        self.emit('data', data);\n      });\n      return;\n    } else if (datatype === ArrayBuffer) {\n      data = util.unpack(data);\n    } else if (datatype === String) {\n      // String fallback for binary data for browsers that don't support binary yet\n      var ab = util.binaryStringToArrayBuffer(data);\n      data = util.unpack(ab);\n    }\n  } else if (this.serialization === 'json') {\n    data = JSON.parse(data);\n  }\n\n  // Check if we've chunked--if so, piece things back together.\n  // We're guaranteed that this isn't 0.\n  if (data.__peerData) {\n    var id = data.__peerData;\n    var chunkInfo = this._chunkedData[id] || {data: [], count: 0, total: data.total};\n\n    chunkInfo.data[data.n] = data.data;\n    chunkInfo.count += 1;\n\n    if (chunkInfo.total === chunkInfo.count) {\n      // Clean up before making the recursive call to `_handleDataMessage`.\n      delete this._chunkedData[id];\n\n      // We've received all the chunks--time to construct the complete data.\n      data = new Blob(chunkInfo.data);\n      this._handleDataMessage({data: data});\n    }\n\n    this._chunkedData[id] = chunkInfo;\n    return;\n  }\n\n  this.emit('data', data);\n}\n\n/**\n * Exposed functionality for users.\n */\n\n/** Allows user to close connection. */\nDataConnection.prototype.close = function() {\n  if (!this.open) {\n    return;\n  }\n  this.open = false;\n  Negotiator.cleanup(this);\n  this.emit('close');\n}\n\n/** Allows user to send data. */\nDataConnection.prototype.send = function(data, chunked) {\n  if (!this.open) {\n    this.emit('error', new Error('Connection is not open. You should listen for the `open` event before sending messages.'));\n    return;\n  }\n  if (this._reliable) {\n    // Note: reliable shim sending will make it so that you cannot customize\n    // serialization.\n    this._reliable.send(data);\n    return;\n  }\n  var self = this;\n  if (this.serialization === 'json') {\n    this._bufferedSend(JSON.stringify(data));\n  } else if (this.serialization === 'binary' || this.serialization === 'binary-utf8') {\n    var blob = util.pack(data);\n\n    // For Chrome-Firefox interoperability, we need to make Firefox \"chunk\"\n    // the data it sends out.\n    var needsChunking = util.chunkedBrowsers[this._peerBrowser] || util.chunkedBrowsers[util.browser];\n    if (needsChunking && !chunked && blob.size > util.chunkedMTU) {\n      this._sendChunks(blob);\n      return;\n    }\n\n    // DataChannel currently only supports strings.\n    if (!util.supports.sctp) {\n      util.blobToBinaryString(blob, function(str) {\n        self._bufferedSend(str);\n      });\n    } else if (!util.supports.binaryBlob) {\n      // We only do this if we really need to (e.g. blobs are not supported),\n      // because this conversion is costly.\n      util.blobToArrayBuffer(blob, function(ab) {\n        self._bufferedSend(ab);\n      });\n    } else {\n      this._bufferedSend(blob);\n    }\n  } else {\n    this._bufferedSend(data);\n  }\n}\n\nDataConnection.prototype._bufferedSend = function(msg) {\n  if (this._buffering || !this._trySend(msg)) {\n    this._buffer.push(msg);\n    this.bufferSize = this._buffer.length;\n  }\n}\n\n// Returns true if the send succeeds.\nDataConnection.prototype._trySend = function(msg) {\n  try {\n    this._dc.send(msg);\n  } catch (e) {\n    this._buffering = true;\n\n    var self = this;\n    setTimeout(function() {\n      // Try again.\n      self._buffering = false;\n      self._tryBuffer();\n    }, 100);\n    return false;\n  }\n  return true;\n}\n\n// Try to send the first message in the buffer.\nDataConnection.prototype._tryBuffer = function() {\n  if (this._buffer.length === 0) {\n    return;\n  }\n\n  var msg = this._buffer[0];\n\n  if (this._trySend(msg)) {\n    this._buffer.shift();\n    this.bufferSize = this._buffer.length;\n    this._tryBuffer();\n  }\n}\n\nDataConnection.prototype._sendChunks = function(blob) {\n  var blobs = util.chunk(blob);\n  for (var i = 0, ii = blobs.length; i < ii; i += 1) {\n    var blob = blobs[i];\n    this.send(blob, true);\n  }\n}\n\nDataConnection.prototype.handleMessage = function(message) {\n  var payload = message.payload;\n\n  switch (message.type) {\n    case 'ANSWER':\n      this._peerBrowser = payload.browser;\n\n      // Forward to negotiator\n      Negotiator.handleSDP(message.type, this, payload.sdp);\n      break;\n    case 'CANDIDATE':\n      Negotiator.handleCandidate(this, payload.candidate);\n      break;\n    default:\n      util.warn('Unrecognized message type:', message.type, 'from peer:', this.peer);\n      break;\n  }\n}\n\nmodule.exports = DataConnection;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/peerjs/lib/dataconnection.js\n// module id = 9\n// module chunks = 0","var util = require('./util');\nvar EventEmitter = require('eventemitter3');\nvar Negotiator = require('./negotiator');\n\n/**\n * Wraps the streaming interface between two Peers.\n */\nfunction MediaConnection(peer, provider, options) {\n  if (!(this instanceof MediaConnection)) return new MediaConnection(peer, provider, options);\n  EventEmitter.call(this);\n\n  this.options = util.extend({}, options);\n\n  this.open = false;\n  this.type = 'media';\n  this.peer = peer;\n  this.provider = provider;\n  this.metadata = this.options.metadata;\n  this.localStream = this.options._stream;\n\n  this.id = this.options.connectionId || MediaConnection._idPrefix + util.randomToken();\n  if (this.localStream) {\n    Negotiator.startConnection(\n      this,\n      {_stream: this.localStream, originator: true}\n    );\n  }\n};\n\nutil.inherits(MediaConnection, EventEmitter);\n\nMediaConnection._idPrefix = 'mc_';\n\nMediaConnection.prototype.addStream = function(remoteStream) {\n  util.log('Receiving stream', remoteStream);\n\n  this.remoteStream = remoteStream;\n  this.emit('stream', remoteStream); // Should we call this `open`?\n\n};\n\nMediaConnection.prototype.handleMessage = function(message) {\n  var payload = message.payload;\n\n  switch (message.type) {\n    case 'ANSWER':\n      // Forward to negotiator\n      Negotiator.handleSDP(message.type, this, payload.sdp);\n      this.open = true;\n      break;\n    case 'CANDIDATE':\n      Negotiator.handleCandidate(this, payload.candidate);\n      break;\n    default:\n      util.warn('Unrecognized message type:', message.type, 'from peer:', this.peer);\n      break;\n  }\n}\n\nMediaConnection.prototype.answer = function(stream) {\n  if (this.localStream) {\n    util.warn('Local stream already exists on this MediaConnection. Are you answering a call twice?');\n    return;\n  }\n\n  this.options._payload._stream = stream;\n\n  this.localStream = stream;\n  Negotiator.startConnection(\n    this,\n    this.options._payload\n  )\n  // Retrieve lost messages stored because PeerConnection not set up.\n  var messages = this.provider._getMessages(this.id);\n  for (var i = 0, ii = messages.length; i < ii; i += 1) {\n    this.handleMessage(messages[i]);\n  }\n  this.open = true;\n};\n\n/**\n * Exposed functionality for users.\n */\n\n/** Allows user to close connection. */\nMediaConnection.prototype.close = function() {\n  if (!this.open) {\n    return;\n  }\n  this.open = false;\n  Negotiator.cleanup(this);\n  this.emit('close')\n};\n\nmodule.exports = MediaConnection;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/peerjs/lib/mediaconnection.js\n// module id = 10\n// module chunks = 0","var util = require('./util');\nvar EventEmitter = require('eventemitter3');\nvar Socket = require('./socket');\nvar MediaConnection = require('./mediaconnection');\nvar DataConnection = require('./dataconnection');\n\n/**\n * A peer who can initiate connections with other peers.\n */\nfunction Peer(id, options) {\n  if (!(this instanceof Peer)) return new Peer(id, options);\n  EventEmitter.call(this);\n\n  // Deal with overloading\n  if (id && id.constructor == Object) {\n    options = id;\n    id = undefined;\n  } else if (id) {\n    // Ensure id is a string\n    id = id.toString();\n  }\n  //\n\n  // Configurize options\n  options = util.extend({\n    debug: 0, // 1: Errors, 2: Warnings, 3: All logs\n    host: util.CLOUD_HOST,\n    port: util.CLOUD_PORT,\n    key: 'peerjs',\n    path: '/',\n    token: util.randomToken(),\n    config: util.defaultConfig\n  }, options);\n  this.options = options;\n  // Detect relative URL host.\n  if (options.host === '/') {\n    options.host = window.location.hostname;\n  }\n  // Set path correctly.\n  if (options.path[0] !== '/') {\n    options.path = '/' + options.path;\n  }\n  if (options.path[options.path.length - 1] !== '/') {\n    options.path += '/';\n  }\n\n  // Set whether we use SSL to same as current host\n  if (options.secure === undefined && options.host !== util.CLOUD_HOST) {\n    options.secure = util.isSecure();\n  }\n  // Set a custom log function if present\n  if (options.logFunction) {\n    util.setLogFunction(options.logFunction);\n  }\n  util.setLogLevel(options.debug);\n  //\n\n  // Sanity checks\n  // Ensure WebRTC supported\n  if (!util.supports.audioVideo && !util.supports.data ) {\n    this._delayedAbort('browser-incompatible', 'The current browser does not support WebRTC');\n    return;\n  }\n  // Ensure alphanumeric id\n  if (!util.validateId(id)) {\n    this._delayedAbort('invalid-id', 'ID \"' + id + '\" is invalid');\n    return;\n  }\n  // Ensure valid key\n  if (!util.validateKey(options.key)) {\n    this._delayedAbort('invalid-key', 'API KEY \"' + options.key + '\" is invalid');\n    return;\n  }\n  // Ensure not using unsecure cloud server on SSL page\n  if (options.secure && options.host === '0.peerjs.com') {\n    this._delayedAbort('ssl-unavailable',\n      'The cloud server currently does not support HTTPS. Please run your own PeerServer to use HTTPS.');\n    return;\n  }\n  //\n\n  // States.\n  this.destroyed = false; // Connections have been killed\n  this.disconnected = false; // Connection to PeerServer killed but P2P connections still active\n  this.open = false; // Sockets and such are not yet open.\n  //\n\n  // References\n  this.connections = {}; // DataConnections for this peer.\n  this._lostMessages = {}; // src => [list of messages]\n  //\n\n  // Start the server connection\n  this._initializeServerConnection();\n  if (id) {\n    this._initialize(id);\n  } else {\n    this._retrieveId();\n  }\n  //\n}\n\nutil.inherits(Peer, EventEmitter);\n\n// Initialize the 'socket' (which is actually a mix of XHR streaming and\n// websockets.)\nPeer.prototype._initializeServerConnection = function() {\n  var self = this;\n  this.socket = new Socket(this.options.secure, this.options.host, this.options.port, this.options.path, this.options.key);\n  this.socket.on('message', function(data) {\n    self._handleMessage(data);\n  });\n  this.socket.on('error', function(error) {\n    self._abort('socket-error', error);\n  });\n  this.socket.on('disconnected', function() {\n    // If we haven't explicitly disconnected, emit error and disconnect.\n    if (!self.disconnected) {\n      self.emitError('network', 'Lost connection to server.');\n      self.disconnect();\n    }\n  });\n  this.socket.on('close', function() {\n    // If we haven't explicitly disconnected, emit error.\n    if (!self.disconnected) {\n      self._abort('socket-closed', 'Underlying socket is already closed.');\n    }\n  });\n};\n\n/** Get a unique ID from the server via XHR. */\nPeer.prototype._retrieveId = function(cb) {\n  var self = this;\n  var http = new XMLHttpRequest();\n  var protocol = this.options.secure ? 'https://' : 'http://';\n  var url = protocol + this.options.host + ':' + this.options.port +\n    this.options.path + this.options.key + '/id';\n  var queryString = '?ts=' + new Date().getTime() + '' + Math.random();\n  url += queryString;\n\n  // If there's no ID we need to wait for one before trying to init socket.\n  http.open('get', url, true);\n  http.onerror = function(e) {\n    util.error('Error retrieving ID', e);\n    var pathError = '';\n    if (self.options.path === '/' && self.options.host !== util.CLOUD_HOST) {\n      pathError = ' If you passed in a `path` to your self-hosted PeerServer, ' +\n        'you\\'ll also need to pass in that same path when creating a new ' +\n        'Peer.';\n    }\n    self._abort('server-error', 'Could not get an ID from the server.' + pathError);\n  };\n  http.onreadystatechange = function() {\n    if (http.readyState !== 4) {\n      return;\n    }\n    if (http.status !== 200) {\n      http.onerror();\n      return;\n    }\n    self._initialize(http.responseText);\n  };\n  http.send(null);\n};\n\n/** Initialize a connection with the server. */\nPeer.prototype._initialize = function(id) {\n  this.id = id;\n  this.socket.start(this.id, this.options.token);\n};\n\n/** Handles messages from the server. */\nPeer.prototype._handleMessage = function(message) {\n  var type = message.type;\n  var payload = message.payload;\n  var peer = message.src;\n  var connection;\n\n  switch (type) {\n    case 'OPEN': // The connection to the server is open.\n      this.emit('open', this.id);\n      this.open = true;\n      break;\n    case 'ERROR': // Server error.\n      this._abort('server-error', payload.msg);\n      break;\n    case 'ID-TAKEN': // The selected ID is taken.\n      this._abort('unavailable-id', 'ID `' + this.id + '` is taken');\n      break;\n    case 'INVALID-KEY': // The given API key cannot be found.\n      this._abort('invalid-key', 'API KEY \"' + this.options.key + '\" is invalid');\n      break;\n\n    //\n    case 'LEAVE': // Another peer has closed its connection to this peer.\n      util.log('Received leave message from', peer);\n      this._cleanupPeer(peer);\n      break;\n\n    case 'EXPIRE': // The offer sent to a peer has expired without response.\n      this.emitError('peer-unavailable', 'Could not connect to peer ' + peer);\n      break;\n    case 'OFFER': // we should consider switching this to CALL/CONNECT, but this is the least breaking option.\n      var connectionId = payload.connectionId;\n      connection = this.getConnection(peer, connectionId);\n\n      if (connection) {\n        util.warn('Offer received for existing Connection ID:', connectionId);\n        //connection.handleMessage(message);\n      } else {\n        // Create a new connection.\n        if (payload.type === 'media') {\n          connection = new MediaConnection(peer, this, {\n            connectionId: connectionId,\n            _payload: payload,\n            metadata: payload.metadata\n          });\n          this._addConnection(peer, connection);\n          this.emit('call', connection);\n        } else if (payload.type === 'data') {\n          connection = new DataConnection(peer, this, {\n            connectionId: connectionId,\n            _payload: payload,\n            metadata: payload.metadata,\n            label: payload.label,\n            serialization: payload.serialization,\n            reliable: payload.reliable\n          });\n          this._addConnection(peer, connection);\n          this.emit('connection', connection);\n        } else {\n          util.warn('Received malformed connection type:', payload.type);\n          return;\n        }\n        // Find messages.\n        var messages = this._getMessages(connectionId);\n        for (var i = 0, ii = messages.length; i < ii; i += 1) {\n          connection.handleMessage(messages[i]);\n        }\n      }\n      break;\n    default:\n      if (!payload) {\n        util.warn('You received a malformed message from ' + peer + ' of type ' + type);\n        return;\n      }\n\n      var id = payload.connectionId;\n      connection = this.getConnection(peer, id);\n\n      if (connection && connection.pc) {\n        // Pass it on.\n        connection.handleMessage(message);\n      } else if (id) {\n        // Store for possible later use\n        this._storeMessage(id, message);\n      } else {\n        util.warn('You received an unrecognized message:', message);\n      }\n      break;\n  }\n};\n\n/** Stores messages without a set up connection, to be claimed later. */\nPeer.prototype._storeMessage = function(connectionId, message) {\n  if (!this._lostMessages[connectionId]) {\n    this._lostMessages[connectionId] = [];\n  }\n  this._lostMessages[connectionId].push(message);\n};\n\n/** Retrieve messages from lost message store */\nPeer.prototype._getMessages = function(connectionId) {\n  var messages = this._lostMessages[connectionId];\n  if (messages) {\n    delete this._lostMessages[connectionId];\n    return messages;\n  } else {\n    return [];\n  }\n};\n\n/**\n * Returns a DataConnection to the specified peer. See documentation for a\n * complete list of options.\n */\nPeer.prototype.connect = function(peer, options) {\n  if (this.disconnected) {\n    util.warn('You cannot connect to a new Peer because you called ' +\n      '.disconnect() on this Peer and ended your connection with the ' +\n      'server. You can create a new Peer to reconnect, or call reconnect ' +\n      'on this peer if you believe its ID to still be available.');\n    this.emitError('disconnected', 'Cannot connect to new Peer after disconnecting from server.');\n    return;\n  }\n  var connection = new DataConnection(peer, this, options);\n  this._addConnection(peer, connection);\n  return connection;\n};\n\n/**\n * Returns a MediaConnection to the specified peer. See documentation for a\n * complete list of options.\n */\nPeer.prototype.call = function(peer, stream, options) {\n  if (this.disconnected) {\n    util.warn('You cannot connect to a new Peer because you called ' +\n      '.disconnect() on this Peer and ended your connection with the ' +\n      'server. You can create a new Peer to reconnect.');\n    this.emitError('disconnected', 'Cannot connect to new Peer after disconnecting from server.');\n    return;\n  }\n  if (!stream) {\n    util.error('To call a peer, you must provide a stream from your browser\\'s `getUserMedia`.');\n    return;\n  }\n  options = options || {};\n  options._stream = stream;\n  var call = new MediaConnection(peer, this, options);\n  this._addConnection(peer, call);\n  return call;\n};\n\n/** Add a data/media connection to this peer. */\nPeer.prototype._addConnection = function(peer, connection) {\n  if (!this.connections[peer]) {\n    this.connections[peer] = [];\n  }\n  this.connections[peer].push(connection);\n};\n\n/** Retrieve a data/media connection for this peer. */\nPeer.prototype.getConnection = function(peer, id) {\n  var connections = this.connections[peer];\n  if (!connections) {\n    return null;\n  }\n  for (var i = 0, ii = connections.length; i < ii; i++) {\n    if (connections[i].id === id) {\n      return connections[i];\n    }\n  }\n  return null;\n};\n\nPeer.prototype._delayedAbort = function(type, message) {\n  var self = this;\n  util.setZeroTimeout(function(){\n    self._abort(type, message);\n  });\n};\n\n/**\n * Destroys the Peer and emits an error message.\n * The Peer is not destroyed if it's in a disconnected state, in which case\n * it retains its disconnected state and its existing connections.\n */\nPeer.prototype._abort = function(type, message) {\n  util.error('Aborting!');\n  if (!this._lastServerId) {\n    this.destroy();\n  } else {\n    this.disconnect();\n  }\n  this.emitError(type, message);\n};\n\n/** Emits a typed error message. */\nPeer.prototype.emitError = function(type, err) {\n  util.error('Error:', err);\n  if (typeof err === 'string') {\n    err = new Error(err);\n  }\n  err.type = type;\n  this.emit('error', err);\n};\n\n/**\n * Destroys the Peer: closes all active connections as well as the connection\n *  to the server.\n * Warning: The peer can no longer create or accept connections after being\n *  destroyed.\n */\nPeer.prototype.destroy = function() {\n  if (!this.destroyed) {\n    this._cleanup();\n    this.disconnect();\n    this.destroyed = true;\n  }\n};\n\n\n/** Disconnects every connection on this peer. */\nPeer.prototype._cleanup = function() {\n  if (this.connections) {\n    var peers = Object.keys(this.connections);\n    for (var i = 0, ii = peers.length; i < ii; i++) {\n      this._cleanupPeer(peers[i]);\n    }\n  }\n  this.emit('close');\n};\n\n/** Closes all connections to this peer. */\nPeer.prototype._cleanupPeer = function(peer) {\n  var connections = this.connections[peer];\n  for (var j = 0, jj = connections.length; j < jj; j += 1) {\n    connections[j].close();\n  }\n};\n\n/**\n * Disconnects the Peer's connection to the PeerServer. Does not close any\n *  active connections.\n * Warning: The peer can no longer create or accept connections after being\n *  disconnected. It also cannot reconnect to the server.\n */\nPeer.prototype.disconnect = function() {\n  var self = this;\n  util.setZeroTimeout(function(){\n    if (!self.disconnected) {\n      self.disconnected = true;\n      self.open = false;\n      if (self.socket) {\n        self.socket.close();\n      }\n      self.emit('disconnected', self.id);\n      self._lastServerId = self.id;\n      self.id = null;\n    }\n  });\n};\n\n/** Attempts to reconnect with the same ID. */\nPeer.prototype.reconnect = function() {\n  if (this.disconnected && !this.destroyed) {\n    util.log('Attempting reconnection to server with ID ' + this._lastServerId);\n    this.disconnected = false;\n    this._initializeServerConnection();\n    this._initialize(this._lastServerId);\n  } else if (this.destroyed) {\n    throw new Error('This peer cannot reconnect to the server. It has already been destroyed.');\n  } else if (!this.disconnected && !this.open) {\n    // Do nothing. We're still connecting the first time.\n    util.error('In a hurry? We\\'re still trying to make the initial connection!');\n  } else {\n    throw new Error('Peer ' + this.id + ' cannot reconnect because it is not disconnected from the server!');\n  }\n};\n\n/**\n * Get a list of available peer IDs. If you're running your own server, you'll\n * want to set allow_discovery: true in the PeerServer options. If you're using\n * the cloud server, email team@peerjs.com to get the functionality enabled for\n * your key.\n */\nPeer.prototype.listAllPeers = function(cb) {\n  cb = cb || function() {};\n  var self = this;\n  var http = new XMLHttpRequest();\n  var protocol = this.options.secure ? 'https://' : 'http://';\n  var url = protocol + this.options.host + ':' + this.options.port +\n    this.options.path + this.options.key + '/peers';\n  var queryString = '?ts=' + new Date().getTime() + '' + Math.random();\n  url += queryString;\n\n  // If there's no ID we need to wait for one before trying to init socket.\n  http.open('get', url, true);\n  http.onerror = function(e) {\n    self._abort('server-error', 'Could not get peers from the server.');\n    cb([]);\n  };\n  http.onreadystatechange = function() {\n    if (http.readyState !== 4) {\n      return;\n    }\n    if (http.status === 401) {\n      var helpfulError = '';\n      if (self.options.host !== util.CLOUD_HOST) {\n        helpfulError = 'It looks like you\\'re using the cloud server. You can email ' +\n          'team@peerjs.com to enable peer listing for your API key.';\n      } else {\n        helpfulError = 'You need to enable `allow_discovery` on your self-hosted ' +\n          'PeerServer to use this feature.';\n      }\n      cb([]);\n      throw new Error('It doesn\\'t look like you have permission to list peers IDs. ' + helpfulError);\n    } else if (http.status !== 200) {\n      cb([]);\n    } else {\n      cb(JSON.parse(http.responseText));\n    }\n  };\n  http.send(null);\n};\n\nmodule.exports = Peer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/peerjs/lib/peer.js\n// module id = 11\n// module chunks = 0","var util = require('./util');\nvar EventEmitter = require('eventemitter3');\n\n/**\n * An abstraction on top of WebSockets and XHR streaming to provide fastest\n * possible connection for peers.\n */\nfunction Socket(secure, host, port, path, key) {\n  if (!(this instanceof Socket)) return new Socket(secure, host, port, path, key);\n\n  EventEmitter.call(this);\n\n  // Disconnected manually.\n  this.disconnected = false;\n  this._queue = [];\n\n  var httpProtocol = secure ? 'https://' : 'http://';\n  var wsProtocol = secure ? 'wss://' : 'ws://';\n  this._httpUrl = httpProtocol + host + ':' + port + path + key;\n  this._wsUrl = wsProtocol + host + ':' + port + path + 'peerjs?key=' + key;\n}\n\nutil.inherits(Socket, EventEmitter);\n\n\n/** Check in with ID or get one from server. */\nSocket.prototype.start = function(id, token) {\n  this.id = id;\n\n  this._httpUrl += '/' + id + '/' + token;\n  this._wsUrl += '&id=' + id + '&token=' + token;\n\n  this._startXhrStream();\n  this._startWebSocket();\n}\n\n\n/** Start up websocket communications. */\nSocket.prototype._startWebSocket = function(id) {\n  var self = this;\n\n  if (this._socket) {\n    return;\n  }\n\n  this._socket = new WebSocket(this._wsUrl);\n\n  this._socket.onmessage = function(event) {\n    try {\n      var data = JSON.parse(event.data);\n    } catch(e) {\n      util.log('Invalid server message', event.data);\n      return;\n    }\n    self.emit('message', data);\n  };\n\n  this._socket.onclose = function(event) {\n    util.log('Socket closed.');\n    self.disconnected = true;\n    self.emit('disconnected');\n  };\n\n  // Take care of the queue of connections if necessary and make sure Peer knows\n  // socket is open.\n  this._socket.onopen = function() {\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n      setTimeout(function(){\n        self._http.abort();\n        self._http = null;\n      }, 5000);\n    }\n    self._sendQueuedMessages();\n    util.log('Socket open');\n  };\n}\n\n/** Start XHR streaming. */\nSocket.prototype._startXhrStream = function(n) {\n  try {\n    var self = this;\n    this._http = new XMLHttpRequest();\n    this._http._index = 1;\n    this._http._streamIndex = n || 0;\n    this._http.open('post', this._httpUrl + '/id?i=' + this._http._streamIndex, true);\n    this._http.onerror = function() {\n      // If we get an error, likely something went wrong.\n      // Stop streaming.\n      clearTimeout(self._timeout);\n      self.emit('disconnected');\n    }\n    this._http.onreadystatechange = function() {\n      if (this.readyState == 2 && this.old) {\n        this.old.abort();\n        delete this.old;\n      } else if (this.readyState > 2 && this.status === 200 && this.responseText) {\n        self._handleStream(this);\n      }\n    };\n    this._http.send(null);\n    this._setHTTPTimeout();\n  } catch(e) {\n    util.log('XMLHttpRequest not available; defaulting to WebSockets');\n  }\n}\n\n\n/** Handles onreadystatechange response as a stream. */\nSocket.prototype._handleStream = function(http) {\n  // 3 and 4 are loading/done state. All others are not relevant.\n  var messages = http.responseText.split('\\n');\n\n  // Check to see if anything needs to be processed on buffer.\n  if (http._buffer) {\n    while (http._buffer.length > 0) {\n      var index = http._buffer.shift();\n      var bufferedMessage = messages[index];\n      try {\n        bufferedMessage = JSON.parse(bufferedMessage);\n      } catch(e) {\n        http._buffer.shift(index);\n        break;\n      }\n      this.emit('message', bufferedMessage);\n    }\n  }\n\n  var message = messages[http._index];\n  if (message) {\n    http._index += 1;\n    // Buffering--this message is incomplete and we'll get to it next time.\n    // This checks if the httpResponse ended in a `\\n`, in which case the last\n    // element of messages should be the empty string.\n    if (http._index === messages.length) {\n      if (!http._buffer) {\n        http._buffer = [];\n      }\n      http._buffer.push(http._index - 1);\n    } else {\n      try {\n        message = JSON.parse(message);\n      } catch(e) {\n        util.log('Invalid server message', message);\n        return;\n      }\n      this.emit('message', message);\n    }\n  }\n}\n\nSocket.prototype._setHTTPTimeout = function() {\n  var self = this;\n  this._timeout = setTimeout(function() {\n    var old = self._http;\n    if (!self._wsOpen()) {\n      self._startXhrStream(old._streamIndex + 1);\n      self._http.old = old;\n    } else {\n      old.abort();\n    }\n  }, 25000);\n}\n\n/** Is the websocket currently open? */\nSocket.prototype._wsOpen = function() {\n  return this._socket && this._socket.readyState == 1;\n}\n\n/** Send queued messages. */\nSocket.prototype._sendQueuedMessages = function() {\n  for (var i = 0, ii = this._queue.length; i < ii; i += 1) {\n    this.send(this._queue[i]);\n  }\n}\n\n/** Exposed send for DC & Peer. */\nSocket.prototype.send = function(data) {\n  if (this.disconnected) {\n    return;\n  }\n\n  // If we didn't get an ID yet, we can't yet send anything so we should queue\n  // up these messages.\n  if (!this.id) {\n    this._queue.push(data);\n    return;\n  }\n\n  if (!data.type) {\n    this.emit('error', 'Invalid message');\n    return;\n  }\n\n  var message = JSON.stringify(data);\n  if (this._wsOpen()) {\n    this._socket.send(message);\n  } else {\n    var http = new XMLHttpRequest();\n    var url = this._httpUrl + '/' + data.type.toLowerCase();\n    http.open('post', url, true);\n    http.setRequestHeader('Content-Type', 'application/json');\n    http.send(message);\n  }\n}\n\nSocket.prototype.close = function() {\n  if (!this.disconnected && this._wsOpen()) {\n    this._socket.close();\n    this.disconnected = true;\n  }\n}\n\nmodule.exports = Socket;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/peerjs/lib/socket.js\n// module id = 12\n// module chunks = 0","var util = require('./util');\n\n/**\n * Reliable transfer for Chrome Canary DataChannel impl.\n * Author: @michellebu\n */\nfunction Reliable(dc, debug) {\n  if (!(this instanceof Reliable)) return new Reliable(dc);\n  this._dc = dc;\n\n  util.debug = debug;\n\n  // Messages sent/received so far.\n  // id: { ack: n, chunks: [...] }\n  this._outgoing = {};\n  // id: { ack: ['ack', id, n], chunks: [...] }\n  this._incoming = {};\n  this._received = {};\n\n  // Window size.\n  this._window = 1000;\n  // MTU.\n  this._mtu = 500;\n  // Interval for setInterval. In ms.\n  this._interval = 0;\n\n  // Messages sent.\n  this._count = 0;\n\n  // Outgoing message queue.\n  this._queue = [];\n\n  this._setupDC();\n};\n\n// Send a message reliably.\nReliable.prototype.send = function(msg) {\n  // Determine if chunking is necessary.\n  var bl = util.pack(msg);\n  if (bl.size < this._mtu) {\n    this._handleSend(['no', bl]);\n    return;\n  }\n\n  this._outgoing[this._count] = {\n    ack: 0,\n    chunks: this._chunk(bl)\n  };\n\n  if (util.debug) {\n    this._outgoing[this._count].timer = new Date();\n  }\n\n  // Send prelim window.\n  this._sendWindowedChunks(this._count);\n  this._count += 1;\n};\n\n// Set up interval for processing queue.\nReliable.prototype._setupInterval = function() {\n  // TODO: fail gracefully.\n\n  var self = this;\n  this._timeout = setInterval(function() {\n    // FIXME: String stuff makes things terribly async.\n    var msg = self._queue.shift();\n    if (msg._multiple) {\n      for (var i = 0, ii = msg.length; i < ii; i += 1) {\n        self._intervalSend(msg[i]);\n      }\n    } else {\n      self._intervalSend(msg);\n    }\n  }, this._interval);\n};\n\nReliable.prototype._intervalSend = function(msg) {\n  var self = this;\n  msg = util.pack(msg);\n  util.blobToBinaryString(msg, function(str) {\n    self._dc.send(str);\n  });\n  if (self._queue.length === 0) {\n    clearTimeout(self._timeout);\n    self._timeout = null;\n    //self._processAcks();\n  }\n};\n\n// Go through ACKs to send missing pieces.\nReliable.prototype._processAcks = function() {\n  for (var id in this._outgoing) {\n    if (this._outgoing.hasOwnProperty(id)) {\n      this._sendWindowedChunks(id);\n    }\n  }\n};\n\n// Handle sending a message.\n// FIXME: Don't wait for interval time for all messages...\nReliable.prototype._handleSend = function(msg) {\n  var push = true;\n  for (var i = 0, ii = this._queue.length; i < ii; i += 1) {\n    var item = this._queue[i];\n    if (item === msg) {\n      push = false;\n    } else if (item._multiple && item.indexOf(msg) !== -1) {\n      push = false;\n    }\n  }\n  if (push) {\n    this._queue.push(msg);\n    if (!this._timeout) {\n      this._setupInterval();\n    }\n  }\n};\n\n// Set up DataChannel handlers.\nReliable.prototype._setupDC = function() {\n  // Handle various message types.\n  var self = this;\n  this._dc.onmessage = function(e) {\n    var msg = e.data;\n    var datatype = msg.constructor;\n    // FIXME: msg is String until binary is supported.\n    // Once that happens, this will have to be smarter.\n    if (datatype === String) {\n      var ab = util.binaryStringToArrayBuffer(msg);\n      msg = util.unpack(ab);\n      self._handleMessage(msg);\n    }\n  };\n};\n\n// Handles an incoming message.\nReliable.prototype._handleMessage = function(msg) {\n  var id = msg[1];\n  var idata = this._incoming[id];\n  var odata = this._outgoing[id];\n  var data;\n  switch (msg[0]) {\n    // No chunking was done.\n    case 'no':\n      var message = id;\n      if (!!message) {\n        this.onmessage(util.unpack(message));\n      }\n      break;\n    // Reached the end of the message.\n    case 'end':\n      data = idata;\n\n      // In case end comes first.\n      this._received[id] = msg[2];\n\n      if (!data) {\n        break;\n      }\n\n      this._ack(id);\n      break;\n    case 'ack':\n      data = odata;\n      if (!!data) {\n        var ack = msg[2];\n        // Take the larger ACK, for out of order messages.\n        data.ack = Math.max(ack, data.ack);\n\n        // Clean up when all chunks are ACKed.\n        if (data.ack >= data.chunks.length) {\n          util.log('Time: ', new Date() - data.timer);\n          delete this._outgoing[id];\n        } else {\n          this._processAcks();\n        }\n      }\n      // If !data, just ignore.\n      break;\n    // Received a chunk of data.\n    case 'chunk':\n      // Create a new entry if none exists.\n      data = idata;\n      if (!data) {\n        var end = this._received[id];\n        if (end === true) {\n          break;\n        }\n        data = {\n          ack: ['ack', id, 0],\n          chunks: []\n        };\n        this._incoming[id] = data;\n      }\n\n      var n = msg[2];\n      var chunk = msg[3];\n      data.chunks[n] = new Uint8Array(chunk);\n\n      // If we get the chunk we're looking for, ACK for next missing.\n      // Otherwise, ACK the same N again.\n      if (n === data.ack[2]) {\n        this._calculateNextAck(id);\n      }\n      this._ack(id);\n      break;\n    default:\n      // Shouldn't happen, but would make sense for message to just go\n      // through as is.\n      this._handleSend(msg);\n      break;\n  }\n};\n\n// Chunks BL into smaller messages.\nReliable.prototype._chunk = function(bl) {\n  var chunks = [];\n  var size = bl.size;\n  var start = 0;\n  while (start < size) {\n    var end = Math.min(size, start + this._mtu);\n    var b = bl.slice(start, end);\n    var chunk = {\n      payload: b\n    }\n    chunks.push(chunk);\n    start = end;\n  }\n  util.log('Created', chunks.length, 'chunks.');\n  return chunks;\n};\n\n// Sends ACK N, expecting Nth blob chunk for message ID.\nReliable.prototype._ack = function(id) {\n  var ack = this._incoming[id].ack;\n\n  // if ack is the end value, then call _complete.\n  if (this._received[id] === ack[2]) {\n    this._complete(id);\n    this._received[id] = true;\n  }\n\n  this._handleSend(ack);\n};\n\n// Calculates the next ACK number, given chunks.\nReliable.prototype._calculateNextAck = function(id) {\n  var data = this._incoming[id];\n  var chunks = data.chunks;\n  for (var i = 0, ii = chunks.length; i < ii; i += 1) {\n    // This chunk is missing!!! Better ACK for it.\n    if (chunks[i] === undefined) {\n      data.ack[2] = i;\n      return;\n    }\n  }\n  data.ack[2] = chunks.length;\n};\n\n// Sends the next window of chunks.\nReliable.prototype._sendWindowedChunks = function(id) {\n  util.log('sendWindowedChunks for: ', id);\n  var data = this._outgoing[id];\n  var ch = data.chunks;\n  var chunks = [];\n  var limit = Math.min(data.ack + this._window, ch.length);\n  for (var i = data.ack; i < limit; i += 1) {\n    if (!ch[i].sent || i === data.ack) {\n      ch[i].sent = true;\n      chunks.push(['chunk', id, i, ch[i].payload]);\n    }\n  }\n  if (data.ack + this._window >= ch.length) {\n    chunks.push(['end', id, ch.length])\n  }\n  chunks._multiple = true;\n  this._handleSend(chunks);\n};\n\n// Puts together a message from chunks.\nReliable.prototype._complete = function(id) {\n  util.log('Completed called for', id);\n  var self = this;\n  var chunks = this._incoming[id].chunks;\n  var bl = new Blob(chunks);\n  util.blobToArrayBuffer(bl, function(ab) {\n    self.onmessage(util.unpack(ab));\n  });\n  delete this._incoming[id];\n};\n\n// Ups bandwidth limit on SDP. Meant to be called during offer/answer.\nReliable.higherBandwidthSDP = function(sdp) {\n  // AS stands for Application-Specific Maximum.\n  // Bandwidth number is in kilobits / sec.\n  // See RFC for more info: http://www.ietf.org/rfc/rfc2327.txt\n\n  // Chrome 31+ doesn't want us munging the SDP, so we'll let them have their\n  // way.\n  var version = navigator.appVersion.match(/Chrome\\/(.*?) /);\n  if (version) {\n    version = parseInt(version[1].split('.').shift());\n    if (version < 31) {\n      var parts = sdp.split('b=AS:30');\n      var replace = 'b=AS:102400'; // 100 Mbps\n      if (parts.length > 1) {\n        return parts[0] + replace + parts[1];\n      }\n    }\n  }\n\n  return sdp;\n};\n\n// Overwritten, typically.\nReliable.prototype.onmessage = function(msg) {};\n\nmodule.exports.Reliable = Reliable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reliable/lib/reliable.js\n// module id = 13\n// module chunks = 0","var BinaryPack = require('js-binarypack');\n\nvar util = {\n  debug: false,\n  \n  inherits: function(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  },\n  extend: function(dest, source) {\n    for(var key in source) {\n      if(source.hasOwnProperty(key)) {\n        dest[key] = source[key];\n      }\n    }\n    return dest;\n  },\n  pack: BinaryPack.pack,\n  unpack: BinaryPack.unpack,\n  \n  log: function () {\n    if (util.debug) {\n      var copy = [];\n      for (var i = 0; i < arguments.length; i++) {\n        copy[i] = arguments[i];\n      }\n      copy.unshift('Reliable: ');\n      console.log.apply(console, copy);\n    }\n  },\n\n  setZeroTimeout: (function(global) {\n    var timeouts = [];\n    var messageName = 'zero-timeout-message';\n\n    // Like setTimeout, but only takes a function argument.\t There's\n    // no time argument (always zero) and no arguments (you have to\n    // use a closure).\n    function setZeroTimeoutPostMessage(fn) {\n      timeouts.push(fn);\n      global.postMessage(messageName, '*');\n    }\t\t\n\n    function handleMessage(event) {\n      if (event.source == global && event.data == messageName) {\n        if (event.stopPropagation) {\n          event.stopPropagation();\n        }\n        if (timeouts.length) {\n          timeouts.shift()();\n        }\n      }\n    }\n    if (global.addEventListener) {\n      global.addEventListener('message', handleMessage, true);\n    } else if (global.attachEvent) {\n      global.attachEvent('onmessage', handleMessage);\n    }\n    return setZeroTimeoutPostMessage;\n  }(this)),\n  \n  blobToArrayBuffer: function(blob, cb){\n    var fr = new FileReader();\n    fr.onload = function(evt) {\n      cb(evt.target.result);\n    };\n    fr.readAsArrayBuffer(blob);\n  },\n  blobToBinaryString: function(blob, cb){\n    var fr = new FileReader();\n    fr.onload = function(evt) {\n      cb(evt.target.result);\n    };\n    fr.readAsBinaryString(blob);\n  },\n  binaryStringToArrayBuffer: function(binary) {\n    var byteArray = new Uint8Array(binary.length);\n    for (var i = 0; i < binary.length; i++) {\n      byteArray[i] = binary.charCodeAt(i) & 0xff;\n    }\n    return byteArray.buffer;\n  },\n  randomToken: function () {\n    return Math.random().toString(36).substr(2);\n  }\n};\n\nmodule.exports = util;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reliable/lib/util.js\n// module id = 14\n// module chunks = 0"],"sourceRoot":""}